<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Atom Bowl ‚Äî Problem</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="apple-touch-icon" href="favicon.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121824;
      --accent: #4f7cff;
      --text: #e6eaf0;
      --muted: #9aa4b2;
      --good: #39d98a;
      --bad: #ff6b6b;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    /* Ambient animated backdrop */
    body::before {
      content: "";
      position: fixed;
      inset: -20vh -20vw;
      background:
        radial-gradient(900px 500px at 20% 10%, rgba(79,124,255,0.28), transparent 55%),
        radial-gradient(700px 420px at 80% 20%, rgba(57,217,138,0.14), transparent 60%),
        radial-gradient(900px 520px at 60% 90%, rgba(255,107,107,0.12), transparent 62%);
      filter: blur(18px);
      opacity: 0.9;
      animation: drift 14s ease-in-out infinite alternate;
      z-index: -2;
      pointer-events: none;
    }

    @keyframes drift {
      from { transform: translate3d(-1.2%, -0.8%, 0) scale(1); }
      to   { transform: translate3d( 1.2%,  0.9%, 0) scale(1.02); }
    }

    /* bottom wave */
    .waves {
      position: fixed;
      left: 0;
      right: 0;
      bottom: -2px;
      height: 170px;
      z-index: -1;
      pointer-events: none;
      opacity: 0.55;
    }

    .waves svg {
      width: 120%;
      height: 100%;
      transform: translateX(-8%);
    }

    .wave1 { animation: waveMove 10s ease-in-out infinite; }
    .wave2 { animation: waveMove 14s ease-in-out infinite reverse; opacity: 0.7; }

    @keyframes waveMove {
      0%   { transform: translateX(-8%); }
      50%  { transform: translateX(-2%); }
      100% { transform: translateX(-8%); }
    }

    /* NAV */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      width: 280px;
      background: var(--panel);
      padding: 24px 24px 48px;
      transform: translateX(-100%);
      transition: transform 0.42s cubic-bezier(.2,.9,.2,1);
      z-index: 1000;
    }

    .nav.open { transform: translateX(0); }

    .nav-title {
      font-weight: 700;
      font-size: 1.4rem;
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .nav a {
      display: flex;
      align-items: center;
      gap: 14px;
      margin: 12px 0;
      padding: 12px 14px;
      border-radius: 12px;
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      transition: background 0.25s, color 0.25s, transform 0.15s;
    }

    .nav a:hover {
      background: rgba(79, 124, 255, 0.15);
      color: var(--accent);
      transform: translateX(4px);
    }

    .icon { width: 22px; text-align: center; }

    .hamburger {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 28px;
      cursor: pointer;
      z-index: 1100;
      user-select: none;
      transition: left 0.35s ease;
    }

    .hamburger.open { left: 300px; }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.42s cubic-bezier(.2,.9,.2,1);
      z-index: 900;
    }

    .overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    /* Engine UI */
    .main {
      padding: 112px 24px 140px;
      max-width: 960px;
      margin: auto;
      min-height: 100vh;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
      margin-bottom: 26px;
      flex-wrap: wrap;
    }

    .pill {
      background: rgba(79,124,255,0.12);
      border: 1px solid rgba(79,124,255,0.28);
      padding: 12px 14px;
      border-radius: 14px;
      color: var(--text);
      font-weight: 700;
      letter-spacing: 0.2px;
      display: inline-flex;
      gap: 10px;
      align-items: center;
      min-width: 160px;
      justify-content: center;
    }

    .pill small { color: var(--muted); font-weight: 700; }

    .question-card {
      background: linear-gradient(145deg, rgba(20,27,46,0.95), rgba(15,21,36,0.92));
      border-radius: 22px;
      padding: 30px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
      transform: translateY(0);
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
      position: relative;
    }

    .question-card:hover {
      transform: translateY(-2px);
      border-color: rgba(79,124,255,0.22);
      box-shadow: 0 26px 70px rgba(0,0,0,0.42);
    }

    .pop { animation: popIn 220ms cubic-bezier(.2,.9,.2,1) both; }

    @keyframes popIn {
      from { opacity: 0; transform: translateY(8px) scale(0.99); }
      to   { opacity: 1; transform: translateY(0) scale(1); }
    }

    .question-img {
      width: 100%;
      border-radius: 14px;
      display: none;
      margin: 18px 0 10px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.06);
      animation: fadeUp 260ms cubic-bezier(.2,.9,.2,1) both;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(6px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    .buzz {
      margin: 18px 0 16px;
      padding: 14px;
      border-radius: 14px;
      background: rgba(79,124,255,0.15);
      border: 1px solid rgba(79,124,255,0.18);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      font-weight: 800;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .buzz .kbd {
      font-weight: 900;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 6px 10px;
      border-radius: 10px;
    }

    .meta {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      margin: 14px 0 10px;
      flex-wrap: wrap;
      color: var(--muted);
      font-weight: 650;
      font-size: 0.92rem;
    }

    .answer-box {
      width: 100%;
      padding: 16px 18px;
      border-radius: 14px;
      border: 2px solid rgba(79,124,255,0.35);
      background: rgba(18,24,36,0.9);
      color: var(--text);
      font-size: 1.05rem;
      outline: none;
      margin: 0 0 12px;
    }

    .answer-box::placeholder { color: rgba(154,164,178,0.8); }

    .answer-box:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 6px rgba(79,124,255,0.12);
    }

    .choices {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin: 0 0 12px;
    }

    .choice-btn {
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 1.15rem;
      font-weight: 900;
      background: linear-gradient(145deg,#1b2440,#0f1524);
      color: var(--text);
      cursor: pointer;
      transition: transform .15s, filter .15s, border-color .15s;
      user-select: none;
    }

    .choice-btn:hover {
      transform: translateY(-2px);
      filter: brightness(1.08);
      border-color: rgba(79,124,255,0.35);
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 14px;
    }

    .btn {
      padding: 12px 18px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 1rem;
      font-weight: 800;
      cursor: pointer;
      background: rgba(79,124,255,0.18);
      color: var(--text);
      transition: transform .15s, filter .15s, background .15s, box-shadow .15s;
      user-select: none;
    }

    .btn.primary {
      background: var(--accent);
      border-color: rgba(79,124,255,0.6);
      color: white;
    }

    .btn.good {
      background: rgba(57,217,138,0.18);
      border-color: rgba(57,217,138,0.55);
    }

    .btn.bad {
      background: rgba(255,107,107,0.16);
      border-color: rgba(255,107,107,0.5);
    }

    .btn.good:hover { filter: brightness(1.12); box-shadow: 0 10px 30px rgba(57,217,138,0.12); }
    .btn.bad:hover  { filter: brightness(1.12); box-shadow: 0 10px 30px rgba(255,107,107,0.12); }

    .btn:hover { transform: translateY(-1px); filter: brightness(1.06); }

    .feedback {
      margin: 18px 0 0;
      min-height: 24px;
      font-weight: 800;
      letter-spacing: 0.2px;
      text-align: center;
      white-space: pre-wrap;
    }

    .feedback.good { color: var(--good); }
    .feedback.bad { color: var(--bad); }

    .hidden { display: none !important; }

    .error {
      background: rgba(255,107,107,0.14);
      border: 1px solid rgba(255,107,107,0.22);
      color: rgba(230,234,240,0.95);
      padding: 14px;
      border-radius: 14px;
      margin-bottom: 14px;
      font-weight: 700;
    }

    .hint {
      margin-top: 10px;
      color: var(--muted);
      text-align: center;
      font-weight: 650;
      font-size: 0.92rem;
    }
  </style>
</head>
<body>

  <div class="waves" aria-hidden="true">
    <svg viewBox="0 0 1440 320" preserveAspectRatio="none">
      <path class="wave1" fill="rgba(79,124,255,0.20)" d="M0,224L48,229.3C96,235,192,245,288,229.3C384,213,480,171,576,154.7C672,139,768,149,864,176C960,203,1056,245,1152,250.7C1248,256,1344,224,1392,208L1440,192L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path>
      <path class="wave2" fill="rgba(57,217,138,0.10)" d="M0,256L60,229.3C120,203,240,149,360,138.7C480,128,600,160,720,170.7C840,181,960,171,1080,186.7C1200,203,1320,245,1380,266.7L1440,288L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path>
    </svg>
  </div>

  <!-- NAV -->
  <div class="nav" id="nav">
    <h2 class="nav-title">‚öõ Atom Bowl</h2>
    <a href="index.html"><span class="icon">üè†</span> Home</a>
    <a href="generate.html"><span class="icon">‚ú®</span> Generate</a>
    <a href="practice_home.html"><span class="icon">‚ö°</span> Practice</a>
    <a href="question_bank.html"><span class="icon">üìö</span> Question Bank</a>
    <a href="settings.html"><span class="icon">‚öôÔ∏è</span> Settings</a>
  </div>

  <div class="overlay" id="overlay"></div>
  <div class="hamburger" id="hamburger">‚ò∞</div>

  <div class="main">
    <div id="err" class="error hidden"></div>

    <div class="topbar">
      <div class="pill"><small>Timer</small> <span id="timer">20</span></div>
      <div class="pill"><small>Score</small> <span id="score">0</span></div>
      <div class="pill"><small>Progress</small> <span id="progress">‚Äî</span></div>
      <div class="pill"><small>Mode</small> <span id="mode">‚Äî</span></div>
    </div>

    <div class="question-card">
      <div class="buzz" id="buzz">Loading‚Ä¶</div>

      <img id="questionImg" class="question-img" src="" alt="Question" />

      <div class="meta">
        <div id="metaLeft">‚Äî</div>
        <div id="metaRight">‚Äî</div>
      </div>

      <input id="answer" class="answer-box hidden" placeholder="Type your answer‚Ä¶" autocomplete="off" />

      <div class="choices hidden" id="choices">
        <button class="choice-btn" type="button" data-letter="W">W</button>
        <button class="choice-btn" type="button" data-letter="X">X</button>
        <button class="choice-btn" type="button" data-letter="Y">Y</button>
        <button class="choice-btn" type="button" data-letter="Z">Z</button>
      </div>

      <div class="row">
        <button class="btn primary hidden" id="submitBtn" type="button">Submit</button>
        <button class="btn good hidden" id="rightBtn" type="button">‚úÖ Right</button>
        <button class="btn bad hidden" id="wrongBtn" type="button">‚ùå Wrong</button>
        <button class="btn hidden" id="nextBtn" type="button">Next</button>
      </div>

      <p class="feedback" id="feedback"></p>

      <!-- Search / Learn buttons (hidden until graded) -->
      <div class="row hidden" id="learnRow">
        <button class="btn" id="searchBtn" type="button">üîç Search</button>
        <button class="btn" id="learnBtn" type="button">ü§ñ Learn</button>
      </div>

      <div class="hint">Tip: Space to buzz (tap card on mobile). W/X/Y/Z keys work after buzzing. Esc goes back. (Grading: R=Right, W=Wrong)</div>
    </div>
  </div>

  <script>
    // NAV
    const nav = document.getElementById('nav');
    const overlay = document.getElementById('overlay');
    const hamburger = document.getElementById('hamburger');

    function toggleNav() {
      const isOpen = nav.classList.toggle('open');
      overlay.classList.toggle('show');
      hamburger.classList.toggle('open');
      hamburger.textContent = isOpen ? '‚úï' : '‚ò∞';
    }

    hamburger.addEventListener('click', toggleNav);
    overlay.addEventListener('click', toggleNav);

    // Run config (single source of truth)
    const DEFAULT_RUN = {
      mode: 'rapid',
      level: 'ANY',
      category: 'ANY',
      qaType: 'ANY',
      bonus: 'ANY',
      count: 25,     // rapid mode: number of PAIRS
      seconds: 20,   // TU pre-buzz timer
      setName: '',
      roundName: ''
    };

    function safeParseJSON(s, fallback) {
      try { return JSON.parse(s); } catch { return fallback; }
    }

    // practice_home should store settings here
    const cfg = safeParseJSON(localStorage.getItem('atom_run'), null) || {};

    const runCfg = {
      ...DEFAULT_RUN,
      ...cfg
    };

    runCfg.qaType = runCfg.qaType || runCfg.qtype || 'ANY';

    runCfg.seconds = parseInt(runCfg.seconds ?? runCfg.time, 10);
    if (!Number.isFinite(runCfg.seconds)) runCfg.seconds = DEFAULT_RUN.seconds;

    runCfg.count = parseInt(runCfg.count, 10);
    if (!Number.isFinite(runCfg.count)) runCfg.count = DEFAULT_RUN.count;
    if (runCfg.count < 1) runCfg.count = 1;

    runCfg.mode = runCfg.mode || DEFAULT_RUN.mode;
    document.getElementById('mode').textContent = runCfg.mode;

    // DOM
    const img = document.getElementById('questionImg');
    const input = document.getElementById('answer');
    const feedback = document.getElementById('feedback');
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const progressEl = document.getElementById('progress');
    const buzzEl = document.getElementById('buzz');
    const choicesEl = document.getElementById('choices');
    const submitBtn = document.getElementById('submitBtn');
    const rightBtn = document.getElementById('rightBtn');
    const wrongBtn = document.getElementById('wrongBtn');
    const nextBtn = document.getElementById('nextBtn');
    const errEl = document.getElementById('err');
    const metaLeft = document.getElementById('metaLeft');
    const metaRight = document.getElementById('metaRight');

    const learnRow = document.getElementById('learnRow');
    const searchBtn = document.getElementById('searchBtn');
    const learnBtn = document.getElementById('learnBtn');

    // State
    let bank = [];
    let questions = [];
    let index = 0;
    let time = 20;
    let timerId = null;
    let buzzed = false;
    let locked = false;
    let awaitingGrade = false;
    let score = 0;
    let runActive = false;

    function animateIn(el) {
      if (!el) return;
      el.classList.remove('pop');
      void el.offsetWidth;
      el.classList.add('pop');
      setTimeout(() => el.classList.remove('pop'), 260);
    }

    function showError(msg) {
      if (!errEl) return;
      errEl.textContent = msg;
      errEl.classList.remove('hidden');
      animateIn(errEl);
    }

    function hideError() {
      if (!errEl) return;
      errEl.classList.add('hidden');
      errEl.textContent = '';
    }

    function norm(s) { return String(s || '').trim(); }

    function currentQ() {
      if (!Array.isArray(questions) || questions.length === 0) return null;
      if (index < 0 || index >= questions.length) return null;
      return questions[index];
    }

    // Image path resolver
    function resolveImgCandidates(q, field) {
      const raw = String((q && q[field]) || '').trim();
      if (!raw) return [];
      if (/^https?:\/\//i.test(raw)) return [raw];

      const p = raw.replace(/^\.\/+/, '').replace(/^\/+/, '');
      if (p.startsWith('images/')) return [p];

      const cands = [];
      if (p.startsWith('ms/') || p.startsWith('hs/')) cands.push('images/' + p);

      const lvl = String(q?.level || '').toLowerCase();
      if (lvl === 'ms' || lvl === 'hs') cands.push(`images/${lvl}/${p}`);

      cands.push('images/' + p);
      cands.push(p);
      return [...new Set(cands)];
    }

    function setImgWithFallback(imgEl, q, field) {
      const cands = resolveImgCandidates(q, field);
      let i = 0;
      imgEl.onerror = null;

      if (!cands.length) {
        imgEl.style.display = 'none';
        imgEl.src = '';
        return;
      }

      imgEl.style.display = 'block';
      imgEl.src = cands[i];
      imgEl.onerror = () => {
        i += 1;
        if (i >= cands.length) {
          imgEl.onerror = null;
          imgEl.style.display = 'none';
          imgEl.src = '';
          return;
        }
        imgEl.src = cands[i];
      };
    }

    function applyFilters(list) {
      const level = runCfg.level;
      const category = runCfg.category;
      const qaType = runCfg.qaType;
      const bonus = runCfg.bonus;
      const setName = norm(runCfg.setName);
      const roundName = norm(runCfg.roundName);

      return list.filter(q => {
        if (level !== 'ANY' && q.level !== level) return false;
        if (category !== 'ANY' && norm(q.category) !== category) return false;
        if (qaType !== 'ANY' && q.type !== qaType) return false;

        // bonus can be ANY / true / false / TU / BONUS
        if (bonus !== 'ANY') {
          const b = String(bonus).toUpperCase().trim();
          const wantBonus = (b === 'TRUE' || b === 'BONUS' || b === 'B');
          const wantTU = (b === 'FALSE' || b === 'TU' || b === 'TOSSUP' || b === 'TOSS-UP' || b === 'T');
          if (wantBonus && !q.bonus) return false;
          if (wantTU && q.bonus) return false;
          if (!wantBonus && !wantTU && String(!!q.bonus) !== String(bonus)) return false;
        }

        if (setName && q.set_name !== setName) return false;
        if (roundName && q.round_name !== roundName) return false;
        return true;
      });
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Pair builder: TU -> BO, same SUBJECT (category) required; same set preferred; same round preferred.
    function buildRunQuestions() {
      const filtered = applyFilters(bank);
      if (!filtered.length) {
        showError('No matches for your run. Go back and loosen filters.');
        return [];
      }
      hideError();

      const mode = String(runCfg.mode || 'rapid').toLowerCase();

      // In tossups/bonuses modes, count means raw questions (not pairs)
      if (mode === 'tossups') {
        const tus = filtered.filter(q => !q.bonus);
        shuffle(tus);
        const n = Math.max(1, parseInt(runCfg.count, 10) || DEFAULT_RUN.count);
        return tus.slice(0, Math.min(n, tus.length));
      }
      if (mode === 'bonuses') {
        const bos = filtered.filter(q => q.bonus);
        shuffle(bos);
        const n = Math.max(1, parseInt(runCfg.count, 10) || DEFAULT_RUN.count);
        return bos.slice(0, Math.min(n, bos.length));
      }

      // Rapid/default: count means number of PAIRS
      const wantPairs = Math.max(1, parseInt(runCfg.count, 10) || DEFAULT_RUN.count);

      // Group by category first (subject is the hard requirement)
      const byCat = new Map();
      for (const q of filtered) {
        const cat = norm(q.category);
        if (!byCat.has(cat)) byCat.set(cat, []);
        byCat.get(cat).push(q);
      }

      const allPairs = [];

      for (const items of byCat.values()) {
        // Prefer pairing within same set
        const bySet = new Map();
        for (const q of items) {
          const key = String(q.set_name || '');
          if (!bySet.has(key)) bySet.set(key, []);
          bySet.get(key).push(q);
        }

        for (const setItems of bySet.values()) {
          const tus = setItems.filter(x => !x.bonus);
          const bos = setItems.filter(x => x.bonus);
          shuffle(tus);
          shuffle(bos);

          const usedBo = new Set();

          for (const t of tus) {
            // Prefer same round first
            let b = bos.find(x => !usedBo.has(x) && String(x.round_name) === String(t.round_name));
            if (!b) b = bos.find(x => !usedBo.has(x));
            if (!b) break;
            usedBo.add(b);
            allPairs.push([t, b]);
          }
        }
      }

      shuffle(allPairs);
      const pickedPairs = allPairs.slice(0, Math.min(wantPairs, allPairs.length));

      // Flatten into TU -> BO order
      const out = [];
      for (const [t, b] of pickedPairs) out.push(t, b);
      return out;
    }

    function updateProgressUI() {
      const q = currentQ();
      if (!q || !Array.isArray(questions) || !questions.length) {
        progressEl.textContent = '‚Äî';
        return;
      }

      const mode = String(runCfg.mode || 'rapid').toLowerCase();

      if (mode === 'tossups' || mode === 'bonuses') {
        // raw question progress
        progressEl.textContent = `${index + 1} / ${questions.length}`;
        return;
      }

      // pair progress
      const pairIndex = Math.floor(index / 2) + 1;
      const totalPairs = Math.max(1, Math.ceil(questions.length / 2));
      const label = q.bonus ? 'BO' : 'TU';
      progressEl.textContent = `${label} ${pairIndex} / ${totalPairs}`;
    }

    function resetForQuestion() {
      buzzed = false;
      locked = false;
      awaitingGrade = false;

      feedback.textContent = '';
      feedback.className = 'feedback';

      input.classList.add('hidden');
      submitBtn.classList.add('hidden');
      choicesEl.classList.add('hidden');
      rightBtn.classList.add('hidden');
      wrongBtn.classList.add('hidden');
      nextBtn.classList.add('hidden');
      learnRow.classList.add('hidden');

      buzzEl.innerHTML = 'Press <span class="kbd">SPACE</span> to buzz';

      const q = currentQ();
      const isBonus = q?.bonus === true;

      // Pre-buzz timing rules
      // TU: custom (runCfg.seconds)
      // BO: always 20s
      const preBuzzTime = isBonus ? 20 : Math.max(5, parseInt(runCfg.seconds, 10) || 20);

      time = preBuzzTime;
      timerEl.textContent = String(time);

      clearInterval(timerId);
      timerId = setInterval(() => {
        time -= 1;
        timerEl.textContent = String(time);
        if (time <= 0) {
          clearInterval(timerId);
          handleTimeout();
        }
      }, 1000);
    }

    function loadQuestion() {
      const q = currentQ();
      if (!q) {
        endRun('No question available.');
        return;
      }

      updateProgressUI();

      setImgWithFallback(img, q, 'question_image');
      img.alt = `Question ${index + 1}`;

      input.value = '';

      const mode = String(runCfg.mode || 'rapid').toLowerCase();
      const isRapid = !['tossups','bonuses'].includes(mode);

      if (isRapid) {
        metaLeft.textContent = `${q.level} ‚Ä¢ ${q.category} ‚Ä¢ ${q.bonus ? 'Bonus' : 'Toss-up'} ‚Ä¢ ${q.type}`;
        metaRight.textContent = `${q.set_name} / ${q.round_name} ‚Ä¢ #${q.num}`;
      } else {
        metaLeft.textContent = `${q.level} ‚Ä¢ ${q.category} ‚Ä¢ ${q.type}`;
        metaRight.textContent = `${q.set_name} / ${q.round_name} ‚Ä¢ #${q.num}`;
      }

      resetForQuestion();

      // Text-to-speech (only if text exists)
      if ('speechSynthesis' in window) {
        const text = String(q.question_text || '').trim();
        if (text) {
          const prefix = q.bonus ? 'Bonus. ' : 'Toss-up. ';
          const utter = new SpeechSynthesisUtterance(prefix + text);
          utter.rate = 0.95;
          utter.pitch = 1.0;
          utter.volume = 0.9;
          window.speechSynthesis.cancel();
          window.speechSynthesis.speak(utter);
        }
      }
    }

    function allowAnswerUI() {
      const q = currentQ();
      if (!runActive || !q) return;

      buzzed = true;
      buzzEl.textContent = 'Buzzed';
      animateIn(buzzEl);

      // After-buzz timing: always 5 seconds (TU & BO)
      clearInterval(timerId);
      time = 5;
      timerEl.textContent = String(time);
      timerId = setInterval(() => {
        time -= 1;
        timerEl.textContent = String(time);
        if (time <= 0) {
          clearInterval(timerId);
          handleTimeout();
        }
      }, 1000);

      if (q.type === 'MC') {
        choicesEl.classList.remove('hidden');
        animateIn(choicesEl);
      } else {
        input.classList.remove('hidden');
        submitBtn.classList.remove('hidden');
        animateIn(input);
        animateIn(submitBtn);
        input.focus();
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function revealManualGrade(userAnswer, correctAnswer) {
      locked = true;
      awaitingGrade = true;
      clearInterval(timerId);

      const ua = norm(userAnswer) || '(no answer)';
      const ca = norm(correctAnswer) || '(no official answer)';

      feedback.innerHTML = `Your answer: <span style="color:var(--text)">${escapeHtml(ua)}</span>\n` +
                          `Official: <span style="color:var(--muted)">${escapeHtml(ca)}</span>`;
      feedback.className = 'feedback';
      animateIn(feedback);

      rightBtn.classList.remove('hidden');
      wrongBtn.classList.remove('hidden');
      animateIn(rightBtn);
      animateIn(wrongBtn);

      nextBtn.classList.add('hidden');
      learnRow.classList.add('hidden');
    }

    function applyGrade(isRight) {
      if (!awaitingGrade) return;
      awaitingGrade = false;

      const q = currentQ();
      const points = q && q.bonus ? 10 : 4;

      if (isRight) {
        score += points;
        scoreEl.textContent = String(score);
        feedback.className = 'feedback good';
        feedback.textContent += ` (+${points})`;
      } else {
        feedback.className = 'feedback bad';
      }

      animateIn(feedback);
      rightBtn.classList.add('hidden');
      wrongBtn.classList.add('hidden');

      // Only show Search/Learn AFTER the user grades
      learnRow.classList.remove('hidden');
      animateIn(learnRow);

      nextBtn.classList.remove('hidden');
      animateIn(nextBtn);
    }

    function submitSA() {
      if (!runActive || !buzzed || locked) return;
      const q = currentQ();
      if (!q) return;
      revealManualGrade(input.value, q.parsed_answer);
    }

    function pickMC(letter) {
      if (!runActive || !buzzed || locked) return;
      const q = currentQ();
      if (!q) return;
      revealManualGrade(letter, q.parsed_answer);
    }

    function handleTimeout() {
      if (!runActive || locked) return;
      const q = currentQ();
      if (!q) return;
      revealManualGrade('', q.parsed_answer);
    }

    function endRun(reason) {
      runActive = false;
      clearInterval(timerId);
      buzzEl.textContent = reason || 'Run complete';

      img.style.display = 'none';
      img.src = '';
      img.alt = '';

      input.classList.add('hidden');
      submitBtn.classList.add('hidden');
      choicesEl.classList.add('hidden');
      rightBtn.classList.add('hidden');
      wrongBtn.classList.add('hidden');
      nextBtn.classList.add('hidden');
      learnRow.classList.add('hidden');

      const mode = String(runCfg.mode || 'rapid').toLowerCase();
      if (mode === 'tossups' || mode === 'bonuses') {
        feedback.textContent = questions.length ? `Final score: ${score}/${questions.length * 4}` : '';
      } else {
        const totalPairs = questions.length ? Math.ceil(questions.length / 2) : 0;
        feedback.textContent = totalPairs ? `Final score: ${score}/${totalPairs * 14}` : '';
      }
      feedback.className = 'feedback';

      progressEl.textContent = '‚Äî';

      buzzed = false;
      locked = true;
      awaitingGrade = false;
    }

    function nextQuestion() {
      if (!runActive) return;
      if (!locked) return;
      if (awaitingGrade) return;

      index += 1;
      if (index >= questions.length) {
        endRun('Run complete');
        return;
      }

      loadQuestion();
    }

    // Events
    window.addEventListener('keydown', (e) => {
      const tag = e.target?.tagName?.toLowerCase();
      const isTyping = tag === 'input' || tag === 'textarea' || e.target?.isContentEditable;

      // Prevent space from scrolling ONLY when not typing (keeps spaces working in answer box)
      if (e.code === 'Space' && !isTyping) e.preventDefault();

      if (e.key === 'Escape') {
        window.location.href = 'practice_home.html';
        return;
      }

      const q = currentQ();
      if (!runActive || !q) return;

      if (awaitingGrade) {
        const k2 = e.key.toUpperCase();
        if (k2 === 'R') applyGrade(true);
        if (k2 === 'W') applyGrade(false);
        return;
      }

      if (e.code === 'Space' && !buzzed && !locked && !isTyping) {
        allowAnswerUI();
        return;
      }

      if (e.code === 'Enter' && buzzed && !locked && q.type === 'SA') submitSA();

      if (buzzed && !locked && q.type === 'MC') {
        const k = e.key.toUpperCase();
        if (['W','X','Y','Z'].includes(k)) pickMC(k);
      }

      if (e.key.toUpperCase() === 'N' && locked) nextQuestion();
    }, { passive: false });

    // Tap / click anywhere to buzz (mobile-friendly)
    const questionCard = document.querySelector('.question-card');

    function shouldIgnoreTap(target) {
      return !!target.closest('input, textarea, button, a, select, label');
    }

    function tapToBuzz(e) {
      if (shouldIgnoreTap(e.target)) return;
      if (!runActive || buzzed || locked || awaitingGrade) return;
      allowAnswerUI();
    }

    if (questionCard) {
      questionCard.addEventListener('pointerdown', tapToBuzz);
    }

    submitBtn.addEventListener('click', submitSA);
    rightBtn.addEventListener('click', () => applyGrade(true));
    wrongBtn.addEventListener('click', () => applyGrade(false));
    nextBtn.addEventListener('click', nextQuestion);

    choicesEl.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-letter]');
      if (!btn) return;
      pickMC(btn.dataset.letter);
    });

    searchBtn.addEventListener('click', () => {
      const q = currentQ();
      if (!q || !q.parsed_answer) return;
      const query = encodeURIComponent(q.parsed_answer);
      window.open(`https://www.bing.com/search?q=${query}`, '_blank');
    });

    learnBtn.addEventListener('click', () => {
      const q = currentQ();
      if (!q) return;
      localStorage.setItem('atom_tutor_context', JSON.stringify({
        answer: q.parsed_answer,
        category: q.category,
        level: q.level
      }));
      window.location.href = 'tutor.html';
    });

    async function loadBank() {
      try {
        const res = await fetch('./set_A.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('set_A.json not found');
        const data = await res.json();
        return Array.isArray(data) ? data : (data.questions || []);
      } catch {
        // Backup demo question (mitochondria)
        return [{
          set_name: 'DEMO',
          round_name: 'demo',
          num: 1,
          bonus: false,
          level: 'MS',
          category: 'BIOLOGY',
          type: 'SA',
          question_text: 'What organelle is known as the powerhouse of the cell?',
          parsed_answer: 'MITOCHONDRIA'
        }];
      }
    }

    // Extra self-tests (console only)
    function runSelfTests() {
      console.assert(!!img && !!input && !!timerEl && !!choicesEl && !!progressEl, 'DOM missing core elements');
      console.assert(typeof currentQ === 'function', 'currentQ missing');

      // Bounds tests
      const savedQuestions = questions;
      const savedIndex = index;

      questions = [];
      index = 0;
      console.assert(currentQ() === null, 'currentQ should be null on empty');

      questions = [{ type: 'SA', level: 'MS', bonus: false, category: 'PHYSICS', question_image: 'ms/Sample-Set-1/m_round02/10_0.png' }];
      index = 1;
      console.assert(currentQ() === null, 'currentQ should be null on OOB index');

      index = 0;
      console.assert(!!currentQ(), 'currentQ should exist in bounds');

      questions = savedQuestions;
      index = savedIndex;

      // Pair-order test
      const mini = [
        { set_name: 'S1', round_name: 'r1', num: 10, bonus: false, level: 'MS', category: 'PHYSICS', type: 'SA', question_image: '' },
        { set_name: 'S1', round_name: 'r1', num: 10, bonus: true,  level: 'MS', category: 'PHYSICS', type: 'SA', question_image: '' },
        { set_name: 'S1', round_name: 'r2', num: 11, bonus: false, level: 'MS', category: 'PHYSICS', type: 'SA', question_image: '' },
        { set_name: 'S1', round_name: 'r2', num: 11, bonus: true,  level: 'MS', category: 'PHYSICS', type: 'SA', question_image: '' },
      ];

      const savedBank = bank;
      const savedCfg = { ...runCfg };

      bank = mini;
      runCfg.level = 'ANY';
      runCfg.category = 'ANY';
      runCfg.qaType = 'ANY';
      runCfg.bonus = 'ANY';
      runCfg.setName = '';
      runCfg.roundName = '';
      runCfg.mode = 'rapid';
      runCfg.count = 2;

      const ra = buildRunQuestions();
      console.assert(ra.length === 4, 'rapid should return 2 pairs => 4 questions');
      console.assert(ra[0].bonus === false && ra[1].bonus === true, 'pair 1 should be TU then BO');
      console.assert(ra[2].bonus === false && ra[3].bonus === true, 'pair 2 should be TU then BO');

      bank = savedBank;
      Object.assign(runCfg, savedCfg);
    }

    (async () => {
      runSelfTests();

      questions = [];
      index = 0;

      bank = await loadBank();
      questions = buildRunQuestions();

      if (!questions.length) {
        runActive = false;
        buzzEl.textContent = 'No questions matched ‚Äî press Esc';
        progressEl.textContent = '‚Äî';
        return;
      }

      runActive = true;
      score = 0;
      scoreEl.textContent = '0';

      loadQuestion();
    })();
  </script>
</body>
</html>
