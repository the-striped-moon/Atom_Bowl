<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Atom Bowl ‚Äî Practice Engine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121824;
      --accent: #4f7cff;
      --text: #e6eaf0;
      --muted: #9aa4b2;
      --good: #39d98a;
      --bad: #ff6b6b;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    /* Ambient animated backdrop */
    body::before {
      content: "";
      position: fixed;
      inset: -20vh -20vw;
      background:
        radial-gradient(900px 500px at 20% 10%, rgba(79,124,255,0.28), transparent 55%),
        radial-gradient(700px 420px at 80% 20%, rgba(57,217,138,0.14), transparent 60%),
        radial-gradient(900px 520px at 60% 90%, rgba(255,107,107,0.12), transparent 62%);
      filter: blur(18px);
      opacity: 0.9;
      animation: drift 14s ease-in-out infinite alternate;
      z-index: -2;
      pointer-events: none;
    }

    @keyframes drift {
      from { transform: translate3d(-1.2%, -0.8%, 0) scale(1); }
      to   { transform: translate3d( 1.2%,  0.9%, 0) scale(1.02); }
    }

    /* bottom wave */
    .waves {
      position: fixed;
      left: 0;
      right: 0;
      bottom: -2px;
      height: 170px;
      z-index: -1;
      pointer-events: none;
      opacity: 0.55;
    }

    .waves svg {
      width: 120%;
      height: 100%;
      transform: translateX(-8%);
    }

    .wave1 { animation: waveMove 10s ease-in-out infinite; }
    .wave2 { animation: waveMove 14s ease-in-out infinite reverse; opacity: 0.7; }

    @keyframes waveMove {
      0%   { transform: translateX(-8%); }
      50%  { transform: translateX(-2%); }
      100% { transform: translateX(-8%); }
    }

    /* NAV */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      width: 280px;
      background: var(--panel);
      padding: 24px 24px 48px;
      transform: translateX(-100%);
      transition: transform 0.42s cubic-bezier(.2,.9,.2,1);
      z-index: 1000;
    }

    .nav.open { transform: translateX(0); }

    .nav-title {
      font-weight: 700;
      font-size: 1.4rem;
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .nav a {
      display: flex;
      align-items: center;
      gap: 14px;
      margin: 12px 0;
      padding: 12px 14px;
      border-radius: 12px;
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      transition: background 0.25s, color 0.25s, transform 0.15s;
    }

    .nav a:hover {
      background: rgba(79, 124, 255, 0.15);
      color: var(--accent);
      transform: translateX(4px);
    }

    .icon { width: 22px; text-align: center; }

    .hamburger {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 28px;
      cursor: pointer;
      z-index: 1100;
      user-select: none;
      transition: left 0.35s ease;
    }

    .hamburger.open { left: 300px; }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.42s cubic-bezier(.2,.9,.2,1);
      z-index: 900;
    }

    .overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    /* Engine UI */
    .main {
      padding: 100px 24px 120px;
      max-width: 960px;
      margin: auto;
      min-height: 100vh;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 18px;
      flex-wrap: wrap;
    }

    .pill {
      background: rgba(79,124,255,0.12);
      border: 1px solid rgba(79,124,255,0.28);
      padding: 10px 12px;
      border-radius: 14px;
      color: var(--text);
      font-weight: 700;
      letter-spacing: 0.2px;
      display: inline-flex;
      gap: 10px;
      align-items: center;
      min-width: 160px;
      justify-content: center;
    }

    .pill small { color: var(--muted); font-weight: 700; }

    .question-card {
      background: linear-gradient(145deg, rgba(20,27,46,0.95), rgba(15,21,36,0.92));
      border-radius: 20px;
      padding: 24px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
      transform: translateY(0);
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
    }

    .question-card:hover {
      transform: translateY(-2px);
      border-color: rgba(79,124,255,0.22);
      box-shadow: 0 26px 70px rgba(0,0,0,0.42);
    }

    .pop { animation: popIn 220ms cubic-bezier(.2,.9,.2,1) both; }

    @keyframes popIn {
      from { opacity: 0; transform: translateY(8px) scale(0.99); }
      to   { opacity: 1; transform: translateY(0) scale(1); }
    }

    .question-img {
      width: 100%;
      border-radius: 14px;
      display: block;
      margin: 12px 0 6px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .buzz {
      margin: 14px 0;
      padding: 14px;
      border-radius: 14px;
      background: rgba(79,124,255,0.15);
      border: 1px solid rgba(79,124,255,0.18);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      font-weight: 800;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .buzz .kbd {
      font-weight: 900;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 6px 10px;
      border-radius: 10px;
    }

    .meta {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      margin: 8px 0 0;
      flex-wrap: wrap;
      color: var(--muted);
      font-weight: 650;
      font-size: 0.92rem;
    }

    .answer-box {
      width: 100%;
      padding: 16px 18px;
      border-radius: 14px;
      border: 2px solid rgba(79,124,255,0.35);
      background: rgba(18,24,36,0.9);
      color: var(--text);
      font-size: 1.05rem;
      outline: none;
      margin: 0 0 12px;
    }

    .answer-box::placeholder { color: rgba(154,164,178,0.8); }

    .answer-box:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 6px rgba(79,124,255,0.12);
    }

    .choices {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin: 0 0 12px;
    }

    .choice-btn {
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 1.15rem;
      font-weight: 900;
      background: linear-gradient(145deg,#1b2440,#0f1524);
      color: var(--text);
      cursor: pointer;
      transition: transform .15s, filter .15s, border-color .15s;
      user-select: none;
    }

    .choice-btn:hover {
      transform: translateY(-2px);
      filter: brightness(1.08);
      border-color: rgba(79,124,255,0.35);
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .btn {
      padding: 12px 18px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 1rem;
      font-weight: 800;
      cursor: pointer;
      background: rgba(79,124,255,0.18);
      color: var(--text);
      transition: transform .15s, filter .15s, background .15s, box-shadow .15s;
      user-select: none;
    }

    .btn.primary {
      background: var(--accent);
      border-color: rgba(79,124,255,0.6);
      color: white;
    }

    .btn.good {
      background: rgba(57,217,138,0.18);
      border-color: rgba(57,217,138,0.55);
    }

    .btn.bad {
      background: rgba(255,107,107,0.16);
      border-color: rgba(255,107,107,0.5);
    }

    .btn.good:hover { filter: brightness(1.12); box-shadow: 0 10px 30px rgba(57,217,138,0.12); }
    .btn.bad:hover  { filter: brightness(1.12); box-shadow: 0 10px 30px rgba(255,107,107,0.12); }

    .btn:hover { transform: translateY(-1px); filter: brightness(1.06); }

    .feedback {
      margin: 14px 0 0;
      min-height: 24px;
      font-weight: 800;
      letter-spacing: 0.2px;
      text-align: center;
    }

    .feedback.good { color: var(--good); }
    .feedback.bad { color: var(--bad); }

    .hidden { display: none !important; }

    .error {
      background: rgba(255,107,107,0.14);
      border: 1px solid rgba(255,107,107,0.22);
      color: rgba(230,234,240,0.95);
      padding: 14px;
      border-radius: 14px;
      margin-bottom: 14px;
      font-weight: 700;
    }

    .hint {
      margin-top: 10px;
      color: var(--muted);
      text-align: center;
      font-weight: 650;
      font-size: 0.92rem;
    }
  </style>
</head>
<body>

  <div class="waves" aria-hidden="true">
    <svg viewBox="0 0 1440 320" preserveAspectRatio="none">
      <path class="wave1" fill="rgba(79,124,255,0.20)" d="M0,224L48,229.3C96,235,192,245,288,229.3C384,213,480,171,576,154.7C672,139,768,149,864,176C960,203,1056,245,1152,250.7C1248,256,1344,224,1392,208L1440,192L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path>
      <path class="wave2" fill="rgba(57,217,138,0.10)" d="M0,256L60,229.3C120,203,240,149,360,138.7C480,128,600,160,720,170.7C840,181,960,171,1080,186.7C1200,203,1320,245,1380,266.7L1440,288L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path>
    </svg>
  </div>

  <!-- NAV -->
  <div class="nav" id="nav">
    <h2 class="nav-title">‚öõ Atom Bowl</h2>
    <a href="index.html"><span class="icon">üè†</span> Home</a>
    <a href="#"><span class="icon">‚ú®</span> Generate</a>
    <a href="practice_home.html"><span class="icon">‚ö°</span> Practice</a>
    <a href="#"><span class="icon">üìö</span> Question Bank</a>
    <a href="#"><span class="icon">‚öôÔ∏è</span> Settings</a>
  </div>

  <div class="overlay" id="overlay"></div>
  <div class="hamburger" id="hamburger">‚ò∞</div>

  <div class="main">
    <div id="err" class="error hidden"></div>

    <div class="topbar">
      <div class="pill"><small>Timer</small> <span id="timer">20</span></div>
      <div class="pill"><small>Score</small> <span id="score">0</span></div>
      <div class="pill"><small>Q</small> <span id="qnum">0</span>/<span id="qtotal">0</span></div>
      <div class="pill"><small>Mode</small> <span id="mode">‚Äî</span></div>
    </div>

    <div class="question-card">
      <div class="buzz" id="buzz">Loading‚Ä¶</div>

      <img id="questionImg" class="question-img" src="" alt="Question" />

      <div class="meta">
        <div id="metaLeft">‚Äî</div>
        <div id="metaRight">‚Äî</div>
      </div>

      <input id="answer" class="answer-box hidden" placeholder="Type your answer‚Ä¶" autocomplete="off" />

      <div class="choices hidden" id="choices">
        <button class="choice-btn" type="button" data-letter="W">W</button>
        <button class="choice-btn" type="button" data-letter="X">X</button>
        <button class="choice-btn" type="button" data-letter="Y">Y</button>
        <button class="choice-btn" type="button" data-letter="Z">Z</button>
      </div>

      <div class="row">
        <button class="btn primary hidden" id="submitBtn" type="button">Submit</button>
        <button class="btn good hidden" id="rightBtn" type="button">‚úÖ Right</button>
        <button class="btn bad hidden" id="wrongBtn" type="button">‚ùå Wrong</button>
        <button class="btn hidden" id="nextBtn" type="button">Next</button>
      </div>

      <p class="feedback" id="feedback"></p>
      <div class="hint">Tip: W/X/Y/Z keys work after buzzing. Press Esc to go back. (Grading: R=Right, W=Wrong)</div>
    </div>
  </div>

  <script>
    // NAV
    const nav = document.getElementById('nav');
    const overlay = document.getElementById('overlay');
    const hamburger = document.getElementById('hamburger');

    function toggleNav() {
      const isOpen = nav.classList.toggle('open');
      overlay.classList.toggle('show');
      hamburger.classList.toggle('open');
      hamburger.textContent = isOpen ? '‚úï' : '‚ò∞';
    }

    hamburger.addEventListener('click', toggleNav);
    overlay.addEventListener('click', toggleNav);

    // Run config from practice_home
    const DEFAULT_RUN = {
      mode: 'rapid',
      level: 'ANY',
      category: 'ANY',
      qaType: 'ANY',
      bonus: 'ANY',
      count: 25,
      seconds: 20,
      setName: '',
      roundName: ''
    };

    function safeParseJSON(s, fallback) {
      try { return JSON.parse(s); } catch { return fallback; }
    }

    const cfgNew = safeParseJSON(localStorage.getItem('atom_practice_config'), null);
    const cfgOld = safeParseJSON(localStorage.getItem('atom_run'), null);
    const runCfg = { ...DEFAULT_RUN, ...(cfgOld || {}), ...(cfgNew || {}) };

    runCfg.qaType = runCfg.qaType || runCfg.qtype || 'ANY';
    runCfg.seconds = runCfg.seconds || runCfg.time || DEFAULT_RUN.seconds;
    runCfg.count = runCfg.count || DEFAULT_RUN.count;

    document.getElementById('mode').textContent = runCfg.mode;

    // DOM
    const img = document.getElementById('questionImg');
    const input = document.getElementById('answer');
    const feedback = document.getElementById('feedback');
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const qnumEl = document.getElementById('qnum');
    const qtotalEl = document.getElementById('qtotal');
    const buzzEl = document.getElementById('buzz');
    const choicesEl = document.getElementById('choices');
    const submitBtn = document.getElementById('submitBtn');
    const rightBtn = document.getElementById('rightBtn');
    const wrongBtn = document.getElementById('wrongBtn');
    const nextBtn = document.getElementById('nextBtn');
    const errEl = document.getElementById('err');
    const metaLeft = document.getElementById('metaLeft');
    const metaRight = document.getElementById('metaRight');

    // State
    let bank = [];
    let questions = [];
    let index = 0;
    let time = 20;
    let timerId = null;
    let buzzed = false;
    let locked = false;
    let awaitingGrade = false;
    let score = 0;
    let runActive = false;

    function animateIn(el) {
      if (!el) return;
      el.classList.remove('pop');
      void el.offsetWidth;
      el.classList.add('pop');
      setTimeout(() => el.classList.remove('pop'), 260);
    }

    function showError(msg) {
      errEl.textContent = msg;
      errEl.classList.remove('hidden');
      animateIn(errEl);
    }

    function hideError() {
      errEl.classList.add('hidden');
      errEl.textContent = '';
    }

    function norm(s) { return String(s || '').trim(); }

    function currentQ() {
      if (!Array.isArray(questions) || questions.length === 0) return null;
      if (index < 0 || index >= questions.length) return null;
      return questions[index];
    }

    // Image path resolver
    function resolveImgCandidates(q, field) {
      const raw = String((q && q[field]) || '').trim();
      if (!raw) return [];
      if (/^https?:\/\//i.test(raw)) return [raw];

      const p = raw.replace(/^\.\/+/, '').replace(/^\/+/, '');
      if (p.startsWith('images/')) return [p];

      const cands = [];
      if (p.startsWith('ms/') || p.startsWith('hs/')) cands.push('images/' + p);

      const lvl = String(q?.level || '').toLowerCase();
      if (lvl === 'ms' || lvl === 'hs') cands.push(`images/${lvl}/${p}`);

      cands.push('images/' + p);
      cands.push(p);
      return [...new Set(cands)];
    }

    function setImgWithFallback(imgEl, q, field) {
      const cands = resolveImgCandidates(q, field);
      let i = 0;
      imgEl.onerror = null;
      if (!cands.length) {
        imgEl.src = '';
        return;
      }
      imgEl.src = cands[i];
      imgEl.onerror = () => {
        i += 1;
        if (i >= cands.length) {
          imgEl.onerror = null;
          return;
        }
        imgEl.src = cands[i];
      };
    }

    function applyFilters(list) {
      const level = runCfg.level;
      const category = runCfg.category;
      const qaType = runCfg.qaType;
      const bonus = runCfg.bonus;
      const setName = norm(runCfg.setName);
      const roundName = norm(runCfg.roundName);

      return list.filter(q => {
        if (level !== 'ANY' && q.level !== level) return false;
        if (category !== 'ANY' && norm(q.category) !== category) return false;
        if (qaType !== 'ANY' && q.type !== qaType) return false;
        if (bonus !== 'ANY' && String(!!q.bonus) !== String(bonus)) return false;
        if (setName && q.set_name !== setName) return false;
        if (roundName && q.round_name !== roundName) return false;
        if (!q.question_image) return false;
        return true;
      });
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function buildRunQuestions() {
      const filtered = applyFilters(bank);
      if (!filtered.length) {
        const parts = [];
        if (runCfg.level !== 'ANY') parts.push(`level=${runCfg.level}`);
        if (runCfg.category !== 'ANY') parts.push(`category=${runCfg.category}`);
        if (runCfg.qaType !== 'ANY') parts.push(`type=${runCfg.qaType}`);
        if (runCfg.bonus !== 'ANY') parts.push(`bonus=${runCfg.bonus}`);
        if (norm(runCfg.setName)) parts.push(`set_name=${runCfg.setName}`);
        if (norm(runCfg.roundName)) parts.push(`round_name=${runCfg.roundName}`);
        showError(`No matches for your run. Go back and loosen filters. (${parts.join(', ') || 'no filters'})`);
        return [];
      }

      hideError();

      // Enforce Toss-up -> Bonus pairing WITHIN THE SAME set+round.
      // Prefer exact num match (TU num == Bonus num). If not found, use any remaining bonus in same round.
      const byRound = new Map();
      for (const q of filtered) {
        const key = `${q.set_name}||${q.round_name}`;
        if (!byRound.has(key)) byRound.set(key, []);
        byRound.get(key).push(q);
      }

      const roundKeys = Array.from(byRound.keys());
      shuffle(roundKeys);

      const paired = [];

      for (const key of roundKeys) {
        const items = byRound.get(key) || [];
        const tossups = items.filter(q => !q.bonus);
        const bonuses = items.filter(q => q.bonus);

        // Shuffle tossups so practice feels random, but keep pairing correctness.
        shuffle(tossups);

        // Build bonus lookup tables
        const bonusByNum = new Map();
        for (const b of bonuses) {
          const n = Number.isFinite(b.num) ? b.num : parseInt(b.num, 10);
          const bn = Number.isFinite(n) ? n : b.num;
          if (!bonusByNum.has(bn)) bonusByNum.set(bn, []);
          bonusByNum.get(bn).push(b);
        }
        // Shuffle each bucket to avoid always the same bonus when duplicates exist
        for (const arr of bonusByNum.values()) shuffle(arr);

        const remainingBonuses = bonuses.slice();
        shuffle(remainingBonuses);

        const usedBonus = new Set();

        for (const t of tossups) {
          // TU always goes first
          paired.push(t);

          // Try to find matching bonus by num
          let match = null;
          const tn = Number.isFinite(t.num) ? t.num : parseInt(t.num, 10);
          const tnum = Number.isFinite(tn) ? tn : t.num;

          const bucket = bonusByNum.get(tnum);
          if (bucket && bucket.length) {
            while (bucket.length) {
              const cand = bucket.pop();
              if (cand && !usedBonus.has(cand)) { match = cand; break; }
            }
          }

          // Fallback: any bonus in the same round not used yet
          if (!match) {
            while (remainingBonuses.length) {
              const cand = remainingBonuses.pop();
              if (cand && !usedBonus.has(cand)) { match = cand; break; }
            }
          }

          // If we couldn't find a bonus, remove the TU we just added (keeps TU->Bonus rhythm)
          if (!match) {
            paired.pop();
            continue;
          }

          usedBonus.add(match);
          paired.push(match);
        }
      }

      let n = Math.max(2, Math.min(100, parseInt(runCfg.count, 10) || 25));
      // Keep TU->Bonus rhythm (even length)
      if (n % 2 === 1) n -= 1;

      return paired.slice(0, Math.min(n, paired.length));
    }

    function resetForQuestion() {
      buzzed = false;
      locked = false;
      awaitingGrade = false;

      feedback.textContent = '';
      feedback.className = 'feedback';

      input.classList.add('hidden');
      submitBtn.classList.add('hidden');
      choicesEl.classList.add('hidden');
      rightBtn.classList.add('hidden');
      wrongBtn.classList.add('hidden');
      nextBtn.classList.add('hidden');

      buzzEl.innerHTML = 'Press <span class="kbd">SPACE</span> to buzz';

      time = Math.max(5, Math.min(30, parseInt(runCfg.seconds, 10) || 20));
      timerEl.textContent = String(time);

      clearInterval(timerId);
      timerId = setInterval(() => {
        time -= 1;
        timerEl.textContent = String(time);
        if (time <= 0) {
          clearInterval(timerId);
          handleTimeout();
        }
      }, 1000);
    }

    function loadQuestion() {
      const q = currentQ();
      if (!q) {
        endRun('No question available.');
        return;
      }

      qnumEl.textContent = String(index + 1);
      qtotalEl.textContent = String(questions.length);

      setImgWithFallback(img, q, 'question_image');
      img.alt = `Question ${index + 1}`;

      input.value = '';
      metaLeft.textContent = `${q.level} ‚Ä¢ ${q.category} ‚Ä¢ ${q.bonus ? 'Bonus' : 'Toss-up'} ‚Ä¢ ${q.type}`;
      metaRight.textContent = `${q.set_name} / ${q.round_name} ‚Ä¢ #${q.num}`;

      resetForQuestion();

      // Text-to-speech (only if text exists)
      if ('speechSynthesis' in window) {
        const text = String(q.question_text || '').trim();
        if (text) {
          const prefix = q.bonus ? 'Bonus. ' : 'Toss-up. ';
          const utter = new SpeechSynthesisUtterance(prefix + text);
          utter.rate = 0.95;
          utter.pitch = 1.0;
          utter.volume = 0.9;
          window.speechSynthesis.cancel();
          window.speechSynthesis.speak(utter);
        }
      }
    }

    function allowAnswerUI() {
      const q = currentQ();
      if (!runActive || !q) return;

      buzzed = true;
      buzzEl.textContent = 'Buzzed';
      animateIn(buzzEl);

      if (q.type === 'MC') {
        choicesEl.classList.remove('hidden');
        animateIn(choicesEl);
      } else {
        input.classList.remove('hidden');
        submitBtn.classList.remove('hidden');
        animateIn(input);
        animateIn(submitBtn);
        input.focus();
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function revealManualGrade(userAnswer, correctAnswer) {
      locked = true;
      awaitingGrade = true;
      clearInterval(timerId);

      const ua = norm(userAnswer) || '(no answer)';
      const ca = norm(correctAnswer) || '(no official answer)';

      feedback.innerHTML = `Your answer: <span style="color:var(--text)">${escapeHtml(ua)}</span><br>` +
                          `Official: <span style="color:var(--muted)">${escapeHtml(ca)}</span>`;
      feedback.className = 'feedback';
      animateIn(feedback);

      rightBtn.classList.remove('hidden');
      wrongBtn.classList.remove('hidden');
      animateIn(rightBtn);
      animateIn(wrongBtn);

      nextBtn.classList.add('hidden');
    }

    function applyGrade(isRight) {
      if (!awaitingGrade) return;
      awaitingGrade = false;

      const q = currentQ();
      const points = q && q.bonus ? 10 : 4;

      if (isRight) {
        score += points;
        scoreEl.textContent = String(score);
        feedback.className = 'feedback good';
        feedback.textContent += ` (+${points})`;
      } else {
        feedback.className = 'feedback bad';
      }

      animateIn(feedback);
      rightBtn.classList.add('hidden');
      wrongBtn.classList.add('hidden');

      nextBtn.classList.remove('hidden');
      animateIn(nextBtn);
    }

    function submitSA() {
      if (!runActive || !buzzed || locked) return;
      const q = currentQ();
      if (!q) return;
      revealManualGrade(input.value, q.parsed_answer);
    }

    function pickMC(letter) {
      if (!runActive || !buzzed || locked) return;
      const q = currentQ();
      if (!q) return;
      revealManualGrade(letter, q.parsed_answer);
    }

    function handleTimeout() {
      if (!runActive || locked) return;
      const q = currentQ();
      if (!q) return;
      revealManualGrade('', q.parsed_answer);
    }

    function endRun(reason) {
      runActive = false;
      clearInterval(timerId);
      buzzEl.textContent = reason || 'Run complete';

      img.src = '';
      img.alt = '';

      input.classList.add('hidden');
      submitBtn.classList.add('hidden');
      choicesEl.classList.add('hidden');
      rightBtn.classList.add('hidden');
      wrongBtn.classList.add('hidden');
      nextBtn.classList.add('hidden');

      const total = Array.isArray(questions) ? questions.length : 0;
      feedback.textContent = total ? `Final score: ${score}/${total}` : '';
      feedback.className = 'feedback';

      qnumEl.textContent = String(total ? Math.min(index + 1, total) : 0);
      qtotalEl.textContent = String(total);

      buzzed = false;
      locked = true;
      awaitingGrade = false;
    }

    function nextQuestion() {
      if (!runActive) return;
      if (!locked) return;
      if (awaitingGrade) return;

      index += 1;
      if (index >= questions.length) {
        endRun('Run complete');
        return;
      }

      loadQuestion();
    }

    // Events
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') e.preventDefault();

      if (e.key === 'Escape') {
        window.location.href = 'practice_home.html';
        return;
      }

      const q = currentQ();
      if (!runActive || !q) return;

      if (awaitingGrade) {
        const k2 = e.key.toUpperCase();
        if (k2 === 'R') applyGrade(true);
        if (k2 === 'W') applyGrade(false);
        return;
      }

      if (e.code === 'Space' && !buzzed && !locked) {
        allowAnswerUI();
        return;
      }

      if (e.code === 'Enter' && buzzed && !locked) {
        if (q.type === 'SA') submitSA();
      }

      if (buzzed && !locked) {
        const k = e.key.toUpperCase();
        if (q.type === 'MC' && ['W','X','Y','Z'].includes(k)) pickMC(k);
      }

      if (e.key.toUpperCase() === 'N' && locked) nextQuestion();
    }, { passive: false });

    submitBtn.addEventListener('click', submitSA);
    rightBtn.addEventListener('click', () => applyGrade(true));
    wrongBtn.addEventListener('click', () => applyGrade(false));
    nextBtn.addEventListener('click', nextQuestion);

    choicesEl.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-letter]');
      if (!btn) return;
      pickMC(btn.dataset.letter);
    });

    async function loadBank() {
      const res = await fetch('./questions.json', { cache: 'no-store' });
      if (!res.ok) throw new Error('questions.json not found in repo root');
      const data = await res.json();
      return Array.isArray(data) ? data : (data.questions || []);
    }

    // Extra self-tests (console only)
    function runSelfTests() {
      console.assert(!!img && !!input && !!timerEl && !!choicesEl, 'DOM missing core elements');
      console.assert(typeof currentQ === 'function', 'currentQ missing');

      // Bounds tests
      questions = [];
      index = 0;
      console.assert(currentQ() === null, 'currentQ should be null on empty');
      questions = [{ type: 'SA', level: 'MS', bonus: false, question_image: 'ms/Sample-Set-1/m_round02/10_0.png' }];
      index = 1;
      console.assert(currentQ() === null, 'currentQ should be null on OOB index');
      index = 0;
      console.assert(!!currentQ(), 'currentQ should exist in bounds');

      // Pairing test (TU then Bonus, same round pairing)
      const mini = [
        { set_name: 'S1', round_name: 'r1', num: 10, bonus: false, level: 'MS', category: 'PHYSICS', type: 'SA', question_image: 'ms/a.png' },
        { set_name: 'S1', round_name: 'r1', num: 10, bonus: true,  level: 'MS', category: 'PHYSICS', type: 'SA', question_image: 'ms/b.png' },
        { set_name: 'S1', round_name: 'r1', num: 11, bonus: false, level: 'MS', category: 'PHYSICS', type: 'SA', question_image: 'ms/c.png' },
        { set_name: 'S1', round_name: 'r1', num: 11, bonus: true,  level: 'MS', category: 'PHYSICS', type: 'SA', question_image: 'ms/d.png' },
        // Different round, should NOT be used as a match for r1
        { set_name: 'S1', round_name: 'r2', num: 10, bonus: true,  level: 'MS', category: 'PHYSICS', type: 'SA', question_image: 'ms/e.png' },
      ];
      const savedBank = bank;
      const savedCfg = { ...runCfg };
      bank = mini;
      runCfg.level = 'ANY';
      runCfg.category = 'ANY';
      runCfg.qaType = 'ANY';
      runCfg.bonus = 'ANY';
      runCfg.setName = '';
      runCfg.roundName = '';
      runCfg.count = 4;
      const out = buildRunQuestions();
      console.assert(out.length === 4, 'paired length should be 4');
      console.assert(out[0].bonus === false && out[1].bonus === true, 'first pair should be TU then Bonus');
      console.assert(out[0].round_name === out[1].round_name && out[0].set_name === out[1].set_name, 'pair 1 must be same set+round');
      console.assert(out[0].num === out[1].num, 'pair 1 should prefer num match');
      console.assert(out[2].bonus === false && out[3].bonus === true, 'second pair should be TU then Bonus');
      console.assert(out[2].round_name === out[3].round_name && out[2].set_name === out[3].set_name, 'pair 2 must be same set+round');
      console.assert(out[2].num === out[3].num, 'pair 2 should prefer num match');
      bank = savedBank;
      Object.assign(runCfg, savedCfg);

      // Image resolver sanity
      const qms = { level: 'MS', question_image: 'ms/Sample-Set-1/m_round02/10_0.png' };
      const qhs = { level: 'HS', question_image: 'Sample-Set-1/round10/4_0.png' };
      const c1 = resolveImgCandidates(qms, 'question_image');
      const c2 = resolveImgCandidates(qhs, 'question_image');
      console.assert(c1[0] === 'images/ms/Sample-Set-1/m_round02/10_0.png', 'ms path should prefix images/');
      console.assert(c2.includes('images/hs/Sample-Set-1/round10/4_0.png'), 'HS fallback should include images/hs/...');
    }

    (async () => {
      runSelfTests();

      questions = [];
      index = 0;

      try {
        bank = await loadBank();
      } catch (e) {
        showError(String(e.message || e));
        qnumEl.textContent = '0';
        qtotalEl.textContent = '0';
        buzzEl.textContent = 'Missing questions.json';
        return;
      }

      questions = buildRunQuestions();
      qtotalEl.textContent = String(questions.length);
      qnumEl.textContent = questions.length ? '1' : '0';

      if (!questions.length) {
        runActive = false;
        buzzEl.textContent = 'No questions matched ‚Äî press Esc';
        return;
      }

      runActive = true;
      score = 0;
      scoreEl.textContent = '0';

      loadQuestion();
    })();
  </script>
</body>
</html>
